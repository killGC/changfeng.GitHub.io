{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"changfeng","url":"https://killgc.github.io/shortfeng"},"pages":[],"posts":[{"title":"HashMap","slug":"HashMap","date":"2018-03-21T04:57:47.000Z","updated":"2018-03-21T05:06:23.000Z","comments":true,"path":"2018/03/21/HashMap/","link":"","permalink":"https://killgc.github.io/shortfeng/2018/03/21/HashMap/","excerpt":"","text":"HashMap 特点： 允许null键/值 非同步 不保证有序（比如插入顺序） 不保证顺序不随时间变化","categories":[],"tags":[]},{"title":"JVM","slug":"JVM","date":"2018-03-19T14:22:30.000Z","updated":"2018-03-22T14:28:16.000Z","comments":true,"path":"2018/03/19/JVM/","link":"","permalink":"https://killgc.github.io/shortfeng/2018/03/19/JVM/","excerpt":"","text":"内存区域 Java内存粗糙的分为堆内存、栈内存 运行时数据区域： 程序计数器 当前线程所执行的字节码的行号指示器，用于线程切换后能恢复到正确的执行位置，线程私有的 Java虚拟机栈 为虚拟机执行Java方法服务，线程私有的 本地方法栈 为虚拟机执行Native方法服务，线程私有的 Java堆 别名GC堆，内存中最大的一块，垃圾收集器管理的主要区域，细分为新生代和老年代，所有线程共享 方法区 别名叫非堆(永久代），用于存储已被虚拟机加载的类信息、常量、静态变量、即使编译器编译后的代码等数据，所有线程共享。运行时常量池畏方法区的一部分。回收的目标主要是针对常量池回收和对类型卸载。 内存相关的异常： StackOverflowError异常 线程请求的栈深度大于虚拟机允许的深度，Java虚拟机栈、本地方法栈区域可能会抛出该异常 OutOfMemoryError异常 虚拟机栈可以动态扩张，如果扩展时无法申请足够的内存。或者在堆中没有内存来分配给对象，并且堆也无法再扩展。或者常量池无法再申请到内存。Java虚拟机栈、本地方法栈、Java堆、常量池区域可能会抛出该异常 垃圾收集算法 最基础的算法为标记-清除，其它收集算法都是基于这种思路并对其不足进行改进而得道。 常用算法： 引用计数算法 存在循环引用问题 标记-清除(mark-sweep)算法 首先标记出所有需要回收的对象，在标记完后统一回收所有被标记的对象。最大的问题为标记和清除的两个过程效率都不高、回收后存在大量不连续的内存碎片、不利于大对象分配 复制算法 将内存空间划分为大小相等的两块，每次只使用其中一块，当一块内存用完，将存活的对象复制到另外一块内存中，然后把用完的一块内存一次清理掉。比标记-清除算法效率高，但是缺点是内存使用率不高（内存缩小为原来的一半）。这种收集算法主要用来收集新生代内存，如果对象存活率较高，就要进行较多的复制操作，效率会变低。 标记-整理(mark-compact)算法 标记过程与标记-清除算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象向一端移动，然后直接清理边界以外的内存。适合老年代内存回收。 新生代： 特点 每次垃圾回收时都会有大批对象死去，只有少量对象存活 组成 将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor。当回收时，将Eden和Survivor中还存活的对象一次性复制到另外一块Survivor空间，最后清理掉Eden和刚才用过的Survivor空间。HotSpot虚拟机默认Eden和Survivor的大小比例为8:1。当Survivor空间不够用，需要依赖其它内存（老年代）进行分配担保 采用复制算法 老年代： 特点 老年代中对象存活率高、没有额外空间对它进行分配担保 采用标记-清理、标记-整理算法 内存分配与回收策略 1、对象优先在Eden分配： 大多数情况，对象在新生代Eden区中分配。当Eden区没有足够内存空间来分配时，虚拟机将发起一次Minor GC。 2、大对象直接进入老年代: 大对象 需要大量连续内存空间的Java对象(典型的如长字符串及数组)，短命大对象，经常出现大对象容易导致内存还有不少空间时就提前触发垃圾收集以获取足够的连续空间来安置它们。 3、长期存活的对象将进入老年代： 给每个对象定义一个对象年龄计算器，对象在Survivor区中每熬过一次Minor GC，年龄就增加1岁，当它的年龄增加到一定程度（默认15岁），将会晋升到老年代。 4、动态对象年龄判定 虚拟机并不是永远地要求对象的年龄必须达到MaxTenuringThreshold才能晋升老年代 如果Suvivor空间中相同年龄所有对象大小总和大于Survivor空间的一半时，年龄大于或等于该年龄的对象就直接进入老年代，无须等到MaxTenuringThreshold要求的年龄 5、空间分配担保 在发生Minor GC之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果条件成立，那么Minor GC可用确保时安全的，如果不成立，则虚拟机会查看HandlePromotionFailure设置值是否允许担保失败。如果允许，那么会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次Minor GC，尽管这次Minor GC时有风险的；如果效应，或者HandlePromotionFailure设置不允许冒险，那这时也要改为进行一次Full GC。 两种GC： Minor GC 新生代GC，Minor GC非常频繁，一般回收速度也比较快 Major GC／Full GC 老年代GC，出现了Major GC，经常会伴随至少一次Minor GC，Major GC的速度一般比Minor GC慢10倍以上。 虚拟机参数 -XX:+option 开启option参数 -XX:-option 关闭option参数 -XX:option=value 将option参数的值设置为value 整个堆大小=年轻代大小 + 年老代大小 + 持久代大小 配置参数： -Xms 初始堆大小 -Xmx 最大堆大小 -Xmn(1.4or lator) 年轻代大小 为eden+ 2个Survivor,增大年轻代后,将会减小年老代大小.此值对系统性能影响较大,Sun官方推荐配置为整个堆的3/8 -XX:NewSize(1.3/1.4) 年轻代大小 -XX:MaxNewSize(1.3/1.4) 年轻代最大值 -XX:PermSize 持久代(perm gen)初始值 -XX:MaxPermSize 持久代最大值 -Xss 每个线程的堆栈大小 -XX:NewRatio 年轻代与年老代的比值 -XX:SurvivorRatio Eden区与Survivor区的大小比值 内存管理参数： -XX:PretenureSizeThreshold 大小超过这个设置值的对象直接在老年代分配，默认值为15 -XX:MaxTenuringThreshold 对象晋升老年代的年龄阀值 调试参数： -XX:+PrintFlagsFinal 输出索引参数的名称及默认值 -XX:+PrintGC 打印GC信息 -XX:+PrintGCDetails 发生垃圾收集行为时打印内存回收日志 -XX:+HeapDumpOnOutOfMemoryError 虚拟机在OOM异常出现之后自动生成dump文件* -XX:+HeapDumpOnCtrlBreak 使用【Ctrl】+【Break】键让虚拟机生成dump文件 JVM优化命令 1、ps：虚拟机进程状况工具 2、jstat：虚拟机统计信息监视工具 显示本地或远程虚拟机进程中的类装载、内存、垃圾收集、JIT编译等运行数据 定位运行期虚拟机性能问题 3、jinfo：Java配置信息工具 4、jmap：Java内存映像工具 用于生产堆转储快照（heapdump或dump文件） 5、jhat：虚拟机堆转储快照分析工具 6、jstack：Java堆栈跟踪工具 用于生成虚拟机当前时刻的线程快照（threaddump或javacore文件） 用于定位线程出现长时间停顿的原因，如果线程间死锁、死循环、请求外部资源导致的长时间等待 类加载机制 类加载器: 类在虚拟机中的唯一性，由加载它的类加载器和这个类本身一同确立；比较两个类是否“相等”，只有这两个类是由同一类加载器加载的前提下才意义，否则，即使两个类来源于同一个class文件，被同一个虚拟机加载，只要加载它们的类加载器不同，那这两个类就必定不相等。 启动类加载器: 或称引导类加载器，Bootstrap ClassLoader，由C++语言实现，是虚拟机自身的一部分，负责将\\lib目录中或被-Xbootclasspath参数所指定的路径中的类库加载到虚拟机内存,启动类加载器无法被Java程序直接引用 扩展类加载器: Extension ClassLoader，由sun.misc.Launcher$ExtClassLoader实现，负责加载\\lib\\ext目录中或被java.ext.dirs系统变量所指定逻辑中的所有类库。 应用程序类加载器: 或称系统类加载器，Applicatiion ClassLoader，由sun.misc.Launcher$AppClassLoader实现，负责加载用户类路径(ClassPath)所指定的类库，一般情况下程序默认使用应用程序类加载器。 由Java实现的类加载器都继承自抽象类java.lang.ClassLoader。 双亲委派模型： 工作过程是：如果一个类加载器收到类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此索引额加载请求最终都应该传送到顶层的启动类加载器中，只有当父类加载器反馈自己无法完成这个加载请求时，子加载器才会尝试自己去加载。 12345678910111213141516171819202122232425262728293031323334353637protected Class&lt;?&gt; loadClass(String name, boolean resolve) throws ClassNotFoundException&#123; synchronized (getClassLoadingLock(name)) &#123; // First, check if the class has already been loaded Class&lt;?&gt; c = findLoadedClass(name); if (c == null) &#123; long t0 = System.nanoTime(); try &#123; if (parent != null) &#123; c = parent.loadClass(name, false); &#125; else &#123; c = findBootstrapClassOrNull(name); &#125; &#125; catch (ClassNotFoundException e) &#123; // ClassNotFoundException thrown if class not found // from the non-null parent class loader &#125; if (c == null) &#123; // If still not found, then invoke findClass in order // to find the class. long t1 = System.nanoTime(); c = findClass(name); // this is the defining class loader; record the stats sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0); sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1); sun.misc.PerfCounter.getFindClasses().increment(); &#125; &#125; if (resolve) &#123; resolveClass(c); &#125; return c; &#125;&#125; 内存模型java内存模型(java memory model JMM)来屏蔽各种硬件和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的内存访问效果。 1、主内存与工作内存 定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节 每个线程有自己的工作内存，工作内存中保存了线程使用到的变量的主内存工作副本，线程对变量的所有操作（读取、赋值）都必须在工作内存中进行；不能直接读写主内存中的变量。 主内存对应Java堆中的对象实例数据部分，而工作内存则对应虚拟机栈中的部分区域。 2、内存交互操作 lock(锁定)：把变量标识为一条线程独占的状态。 unlock(解锁)：把处于锁定状态的变量释放出来。 read(读取)：把变量的值从主内存传输到线程的工作内存中 load(载入)：把read操作从主内存中得到的变量值放入工作内存的变量副本。 use(使用)：把工作内存的变量值传递给执行引擎，每当虚拟机遇到一个需要使用到变量的值的字节码指令时将会执行这个操作。 assign(赋值) 把从执行引擎接收到的值赋给工作内存的变量，每当虚拟机遇到给变量赋值的字节码指令时执行这个操作 store(存储) 把工作内存的值传送到主内存中 write(写入）把store操作从工作内存中得到的变量的值放入主内存的变量中 变量从主内存复制到工作内存，要顺序执行read和load，变量从工作内存同步回主内存，要顺序执行store和write，只要求两个操作顺序执行，而没有保证是连续执行。read和load之间、store和write之间是可以插入其他指令的。如read a、read b、load b、load a。 3、volatile型变量 最轻量级的同步机制 特性： 保证变量对所有线程的可见性，可见性是指一条线程修改了这个变量的值，新值对于其他线程来说是可以立即得到的 每次使用之前都要刷新 新值立即同步到主内存 语义是禁止指令重排序优化 不符合以下规则的运算场景，仍然要通过加锁(synchronized或java.util.concurrent中的原子类)来保证原子性： 运算结果并不依赖当前变量的当前值，或者能够确保只有单一线程修改变量的值。 变量不需要与其他的状态变量共同参与不变约束。 4、long和double型变量的非原子协定 5、原子性、可见性与有序性 原子性： 可见性：除了volatile外，synchronized和final也能实现可见性。 有序性：如果在本线程内观察，所有操作都是有序的；如果在一个线程中观察另外一个线程，所有操作都是无序的。前半句是指线程内表现为串行的语义，后半句是指“指令重排序”现象和“工作内存与主内存同步延迟”现象。volatile和synchronized能保证线程之间操作的有序性。 6、先行发生原则(happen-before) 先行发生是Java内存模型中定义的两项操作之间的偏序关系，如果说操作A先行发生与操作B，其实是说在发生操作B之前，操作A产生的影响能被操作B观察到，“影响”包括修改了内存中共享变量的值、发送了消息、调用了方法","categories":[],"tags":[]},{"title":"mysql","slug":"mysql","date":"2018-03-18T08:23:56.000Z","updated":"2018-03-18T14:55:18.000Z","comments":true,"path":"2018/03/18/mysql/","link":"","permalink":"https://killgc.github.io/shortfeng/2018/03/18/mysql/","excerpt":"","text":"并发控制mysql通过加锁进行并发控制。mysql有两种锁，分别是共享锁和排它锁，也叫读锁和写锁。读锁是共享的，写锁是排它的。多个读锁可以同时存在，但是写锁不能和读锁和写锁共存。在读多写少的场景比较适合读写锁。 按锁的粒度，分为表级锁和行级锁。 Myisam与InnoDB区别 InnoDB支持事务，Myisam不支持 InnoDB支持外键，Myisam不支持 InnoDB是聚集索引，数据文件和索引绑在一起，必须要主键索引；Myisam是非聚集索引，数据文件是分离的，索引保存的是数据文件的指针，主键索引和辅助索引是独立的 InnoDB不保存表的具体行数，执行select count(*) from table是需要全表扫描；而Myisam用一个变量保存整个表的行数，执行上述语句只需要读出该变量即可，速度很快。 InnoDB不支持全文索引，而Myisam支持全文索引。 InnoDB支持行级锁，而Myisam只支持表级锁 聚簇索引和非聚簇索引myisam的主键索引和其它索引没有什么不同，都只是存储了数据的物理位置指针，innoDB的聚簇索引和非聚簇索引很不相同。 聚簇索引：InnoDB一定会建立聚簇索引，把实际数据行与相关的键值保存在一起。 一个表只能有一个聚簇索引 有主键时，根据主键创建聚簇索引 没有主键时，会用一个唯一且不为空的索引列作为主键创建聚簇索引 以上都不满足，隐式定义一个主键作为聚簇索引 主键不能太大 按主键顺序插入行对应高并发，按主键顺序插入行可能会造成主键争用，主键的上限会成为热点，并发插入会导致间隙锁经侦；另外一个热点是auto_increment锁机制 非聚簇索引：非聚簇索引（二级索引），也称为辅助索引 叶子节点保存的不是行的物理位置指针，而是是主键值，当行移动或数据页分裂时无需更新二级索引的物理位置指针。 访问数据需要两次索引查找 B树、B+树、B*树InnoDB使用的是B+树。 B树(B-Tree）：B树作为一种多路搜索树（并不是二叉的） 定义任意非叶子结点最多只有M个儿子；且M&gt;2； 根结点的儿子数为[2, M]； 除根结点以外的非叶子结点的儿子数为[M/2, M]； 每个结点存放至少M/2-1（取上整）和至多M-1个关键字；(至少2个关键字） 非叶子结点的关键字个数=指向儿子的指针个数-1； 非叶子结点的关键字：K[1], K[2], …, K[M-1]；且K[i] &lt; K[i+1]；&gt; * v非叶子结点的指针：P[1], P[2], …, P[M]；其中P[1]指向关键字小于K[1]的子树，P[M]指向关键字大于K[M-1]的子树，其它P[i]指向关键字属于(K[i-1], K[i])的子树； 所有叶子结点位于同一层； B+树(B+tree)：B+树是B树的变体，也是一种多路搜索树，其定义基本与B-树相同，除了： 非叶子结点的子树指针与关键字个数相同； 非叶子结点的子树指针P[i]，指向关键字值属于[K[i], K[i+1])的子树（B-树是开区间）； 为所有叶子结点增加一个链指针； 所有关键字都在叶子结点出现； B+树性质： 所有关键字都出现在叶子结点的链表中（稠密索引），且链表中的关键字恰好是有序的； 不可能在非叶子结点命中； 非叶子结点相当于是叶子结点的索引（稀疏索引），叶子结点相当于是存储（关键字）数据的数据层； 更适合文件索引系统。 B∗树：B*树是B+树的变体，在B+树的非根和非叶子结点再增加指向兄弟的指针，将结点的最低利用率从1/2提高到2/3 B∗树定义了非叶子结点关键字个数至少为23M，即块的最低使用率为2/3（代替B+树的1/2）； B+树的分裂：当一个结点满时，分配一个新的结点，并将原结点中1/2的数据复制到新结点，最后在父结点中增加新结点的指针；B+树的分裂只影响原结点和父结点，而不会影响兄弟结点，所以它不需要指向兄弟的指针； B∗树的分裂：当一个结点满时，如果它的下一个兄弟结点未满，那么将一部分数据移到兄弟结点中，再在原结点插入关键字，最后修改父结点中兄弟结点的关键字（因为兄弟结点的关键字范围改变了）；如果兄弟也满了，则在原结点与兄弟结点之间增加新结点，并各复制1/3的数据到新结点，最后在父结点增加新结点的指针； 所以，B∗树分配新结点的概率比B+树要低，空间使用率更高。","categories":[],"tags":[]},{"title":"spring事务传播机制和隔离级别","slug":"spring事务传播机制和隔离级别","date":"2018-03-15T15:24:57.000Z","updated":"2018-03-18T07:57:33.000Z","comments":true,"path":"2018/03/15/spring事务传播机制和隔离级别/","link":"","permalink":"https://killgc.github.io/shortfeng/2018/03/15/spring事务传播机制和隔离级别/","excerpt":"","text":"spring事务传播机制和隔离级别事务传播机制 propagation_required 支持当前事务，如果不存在事务，则新建一个事务 propagation_supports 支持当前事务，如果不存在事务，则以非事务方式执行 propagation_mandatory 支持当前事务，如果不存在事务，则抛出异常 propagation_required_new 新建事务，如果当前存在事务，则挂起当前事务 propagation_not_supported 以非事务方式执行，如果当前存在事务，则把当前事务挂起 propagation_never 以非事务方式执行，如果当前存在事务，则抛出异常 propagation_nested 如果当前存在事务，则在嵌套事务内执行，如果当前没有事务，则其行为与propagation_required一样。嵌套的事务可以独立于当前事务进行单独的提交或回滚。内部事务的回滚不会对外部事务造成影响，如果外部事务commit, 嵌套事务也会被commit, 这个规则同样适用于 roll back 事务隔离级别 数据库事务并发的三个问题： 脏读 脏读发生在一个事务读取另外一个事务改写未提交的数据，如果改写在稍后被回滚，就有可能出现数据不一致。 不可重复读 一个事务执行相同的查询两次或两次以上，每次得到不同的数据，通常是由于另外一个事务在两次查询期间进行更新。通过锁住满足条件的记录来解决。重点在于update和delete 幻读 一个事务读取了几行数据，另外一个事务插入了一些数据，在后面的查询，第一个事务会发现多了一些原本不存在的记录。通过锁住满足条件及其相近的记录。重点在于insert spring中对应数据库的隔离级别： isolation_default 使用数据库默认的隔离级别 isolation_read_uncommited 读未提交，可能出现脏读、不可重复读、幻读 isolation_read_commited 读已提交，避免了脏读，可能会出现不可重复读、幻读 isolation_repeatable_read 可重复读，避免了脏读、不可重复读，可能出现幻读 isolation_seriablizable 串行访问，避免脏读、不可重复读、幻读。读加共享锁，写加排他锁，读写互斥 数据库隔离级别： mysql数据库的默认隔离级别为repeatable_read，并且解决了幻读问题。 oracle数据库的默认隔离级别为read_commited 回滚机制回滚规则用于定义哪些异常会导致回滚，哪些异常不会导致回滚默认情况下，只有遇到运行时异常才会回滚，遇到受检异常不回滚。 MVCC(多版本并发控制)全称为Multi-Version Currency Control，为了查询一些正在被另外事务更新的行，并且可以看到它们被更新之前的值。可以增强并发，实现查询不用等待另外事务释放锁。 在InnoDB中,给每行增加两个隐藏字段来实现mvcc，一个用来记录行的创建时间，一个用了记录行的过期时间（删除时间）。在实际实现中，存储的并不是时间，而是事务版本号，每开启一个新的事务，事务的版本号就会递增。mysql的默认隔离级别repeatable read下，增删查改的实现为： select 读取创建版本号小于或等于当前事务版本号，且删除版本号为空或大于当前事务版本号的记录，这样可以保证在读取之前记录是存在的 insert 创建版本号为当前事务版本号 update 插入一条新记录，新记录的创建版本号为当前事务版本号，原记录的删除版本号为当前事务版本号 delete 删除版本号为当前事务版本号 Mvcc只支持repeatable read和read commited隔离级别。read uncommited与Mvcc不兼容，因为不能找到适合它们事务版本的行版本，每次读取都是最新版本。serailizable与Mvcc也不兼容，因为每次读操作都会锁定它们返回的每一行数据 快照读和当前读： 快照读 读取的快照版本，也就是历史版本。普通的select是快照读 当前读 读取的是最新版本。update、insert、delete、select .. for update、select .. lock in share mode是当前读 锁定读和一致性非锁定读： 锁定读 事务中标准的select语句是不会加锁的，select .. for update（与update加锁一样）、select .. lock in share mode（加共享锁，其它事务只读不能修改，直到当前事务提交）两种除外。 一致性非锁定读 简称一致性读，读的是数据库某个时间点的快照。如果隔离级别是repeatable_read，同一个事务中的所有一致性非锁定读都读的是事务中第一个读读到的快照版，如果隔离级别为read_commited，那么事务的每一个一致性非锁定读都会读到自己刷新的快照版本。一致性非锁定读不会给它访问的表加任何形式的锁，因此其它事务可以并发的修改它们。 悲观锁和乐观锁： 悲观锁 数据库总是认为别人会修改它所操作的数据，因此在操作数据过程中将数据加锁 乐观锁 总是认为别人不会修改，通过版本来实现 锁： record lock（记录锁） 在索引记录上加锁 grap locks（间隙锁） 在索引记录之间加锁，或者在第一个索引记录之前加锁，或者在最后一个索引记录之后加锁 next key lock 在索引记录上加锁，并且在索引记录之间的间隙加锁，相当于record lock与grap locks的结合 一致性读保证了可重复读，间隙锁防止了幻读。","categories":[],"tags":[]},{"title":"性能优化相关linux命令","slug":"性能优化相关linux命令","date":"2018-03-13T08:48:10.000Z","updated":"2018-03-14T12:56:36.000Z","comments":true,"path":"2018/03/13/性能优化相关linux命令/","link":"","permalink":"https://killgc.github.io/shortfeng/2018/03/13/性能优化相关linux命令/","excerpt":"","text":"性能优化相关linux命令 top命令top命令是Linux下常用的性能分析工具，能够实时显示系统中各个进程的资源占用状况，类似于Windows的任务管理器，查看系统平均负载和 CPU 使用率 平均负载有三个数字：63.66，58.39，57.18，分别表示过去 1 分钟、5 分钟、15 分钟机器的负载。按照经验，若数值小于 0.7*CPU 个数，则系统工作正常；若超过这个值，甚至达到 CPU 核数的四五倍，则系统的负载就明显偏高 命令格式：top [参数] 命令功能：显示当前系统正在执行的进程的相关信息，包括进程ID、内存占用率、CPU占用率等 默认以pid倒序排序命令参数： top [-a | -d | -e | -c &lt;mode&gt;] [-F | -f] [-h] [-i &lt;interval&gt;] [-l &lt;samples&gt;] [-ncols &lt;columns&gt;] [-o &lt;key&gt;] [-O &lt;skey&gt;] [-R | -r] [-S] [-s &lt;delay&gt;] [-n &lt;nprocs&gt;] [-stats &lt;keys&gt;] [-pid &lt;processid&gt;] [-user &lt;username&gt;] [-U &lt;username&gt;] [-u] [-a | -d | -e | -c &lt;mode&gt;] -c &lt;mode&gt; a 累积模式,从top命令执行开始计算 d delta模式 e 绝对模式，计算事件的绝对数量 n 无事件模式，为默认模式 -a 等同与-c a，类似的-d、-e 分别等同与-c d、-c e [-F | -f] -F 不计算共享内存 -f 计算共享内存，默认 [-h] 打印信息并退出 **这个参数执行不了** [-i &lt;interval&gt;] 每隔多少秒更新信息 [-l &lt;samples&gt;] [-ncols &lt;columns&gt;] [-o &lt;key&gt;] [-O &lt;secondaryKey&gt;] -o &lt;key&gt; 第一排序字段 -O &lt;secondaryKey&gt; 第二排序字段 支持以下key，key前面可以带上+或-，用于说明倒序还是正序： pid 默认 cpu cpu_me CPU time charged to me by other processes. cpu_others CPU time charged to other processes by me csw 上下文切换次数 time 执行时间 threads 别名为th，线程数量（总的线程数/运行中线程数） ports 别名prt，机器端口数量 mregion 别名mreg, reg，内存区数量 mem 内存大小 rprvt 常驻私有地址空间大小 purg 可移除内存大小 vsize Total memory size. vprvt Private address space size. kprvt Private kernel memory size. kshrd Shared kernel memory size. pgrp Process group id. ppid Parent process id. state alias: pstate Process state. uid User ID. wq alias: #wq, workqueue The workqueue total/running. faults alias: fault The number of page faults. cow alias: cow_faults The copy-on-write faults. user alias: username Username. msgsent Total number of mach messages sent. msgrecv Total number of mach messages received. sysbsd Total BSD syscalls. sysmach Total Mach syscalls. -R Do not traverse and report the memory object map for each process. -r Traverse and report the memory object map for each process (de- fault). -S Display the global statistics for swap and purgeable memory. -s &lt;delay&gt; 每隔多少秒更新显示 Set the delay between updates to &lt;delay&gt; seconds. The default delay between updates is 1 second. -stats &lt;keys&gt; Only display the comma separated statistics. See the -o flag for the valid &lt;keys&gt;. -pid &lt;processid&gt; Only display &lt;processid&gt; in top. This option may be specified multiple times. -user &lt;user&gt; Only display processes owned by &lt;user&gt;. -U &lt;user&gt; This is an alias for -user. -u This is an alias equivalent to: -o cpu -O time. 交互式命令： ? Display the help screen. Any character exits help screen mode. This command always works, even in the middle of a command. ^L Redraw the screen. c&lt;mode&gt; Set output mode to &lt;mode&gt;. The supported modes are: a Accumulative mode. d Delta mode. e Event mode. n Non-event mode. O&lt;skey&gt; Use &lt;skey&gt; as a secondary key when ordering the process display. See the -o option for key names. o&lt;key&gt; Order the process display by sorting on &lt;key&gt; in descending or- der. A + or - can be prefixed to the key name to specify as- cending or descending order, respectively. The supported keys and alises are listed with the -o option above. q Quit. r Toggle traversal and reporting of the memory object map for each process. S&lt;signal&gt;&lt;pid&gt; Send &lt;sig&gt; to &lt;pid&gt;. &lt;sig&gt; can be specified either as a number or as a name (for example, HUP). The default signal starts out as TERM. Each time a signal is successfully sent, the default signal is updated to be that signal. &lt;pid&gt; is a process id. s&lt;delay&gt; Set the delay between updates to &lt;delay&gt; seconds. U&lt;user&gt; Only display processes owned by &lt;user&gt;. Either the username or uid number can be specified. To display all processes, press enter without entering a username or uid number. 示例： top -o cpu -O +rsize -s 5 -n 20 Sort the processes according to CPU usage (descending) and resi- dent memory size (ascending), sample and update the display at 5 second intervals, and limit the display to 20 processes. top -c d Run top in delta mode. top -stats pid,command,cpu,th,pstate,time Display only the specified statistics, regardless of any growth of the terminal. If the terminal is too small, only the statis- tics that fit will be displayed. 相关命令： kill(2), vm_stat(1), signal(3), vmmap(1)","categories":[],"tags":[]},{"title":"多线程","slug":"多线程","date":"2018-03-12T11:51:15.000Z","updated":"2018-03-12T11:54:36.000Z","comments":true,"path":"2018/03/12/多线程/","link":"","permalink":"https://killgc.github.io/shortfeng/2018/03/12/多线程/","excerpt":"","text":"##多线程三种来实现线程安全的手段: 互斥同步通过加锁来实现对临界资源的访问限制。加锁方式有Synchorized和Lock 非阻塞同步前面提到的互斥同步属于一种悲观锁机制，非阻塞同步属于乐观锁机制。典型的实现方式就是CAS操 作 无同步方案要保证线程安全，并不是一定就需要同步，两者没有因果关系，同步只是保证共享数据征用时正确性的手段，如果一个方法本来就不涉及共享数据，那它就不需要任何同步措施去保证正确性。ThreadLocal就是这张实现方案","categories":[],"tags":[]},{"title":"ThreadLocal","slug":"ThreadLocal","date":"2018-03-12T09:36:17.000Z","updated":"2018-03-12T10:07:41.000Z","comments":true,"path":"2018/03/12/ThreadLocal/","link":"","permalink":"https://killgc.github.io/shortfeng/2018/03/12/ThreadLocal/","excerpt":"","text":"ThreadLocal synchronized 以时间换空间 ThreadLocal 以空间换时间 Thread类保存了ThreadLocalMap类型的变量, ThreadLocalMap的key为ThreadLoacal对象 1ThreadLocal.ThreadLocalMap threadLocals = null; ThreadLocal类，支持范型 12345678910111213public T get() &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) &#123; ThreadLocalMap.Entry e = map.getEntry(this); if (e != null) &#123; @SuppressWarnings(\"unchecked\") T result = (T)e.value; return result; &#125; &#125; return setInitialValue();&#125; 12345678public void set(T value) &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value);&#125; 123ThreadLocalMap getMap(Thread t) &#123; return t.threadLocals;&#125; 12345678910private T setInitialValue() &#123; T value = initialValue(); Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value); return value;&#125; 示例1234567891011121314151617181920212223242526272829import java.sql.Connection;import java.sql.DriverManager;import java.sql.SQLException;public class ConnectionManager &#123; private static ThreadLocal&lt;Connection&gt; connectionHolder = new ThreadLocal&lt;Connection&gt;() &#123; @Override protected Connection initialValue() &#123; Connection conn = null; try &#123; conn = DriverManager.getConnection( \"jdbc:mysql://localhost:3306/test\", \"username\", \"password\"); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; return conn; &#125; &#125;; public static Connection getConnection() &#123; return connectionHolder.get(); &#125; public static void setConnection(Connection conn) &#123; connectionHolder.set(conn); &#125;&#125; 可以创建不同的ThreadLocal实例来实现多个变量在不同线程间的访问隔离，为什么可以这么做？因为不同的ThreadLocal对象作为不同键，当然也可以在线程的ThreadLocalMap对象中设置不同的值了。通过ThreadLocal对象，在多线程中共享一个值和多个值的区别，就像你在一个HashMap对象中存储一个键值对和多个键值对一样，仅此而已","categories":[],"tags":[]},{"title":"spring aop","slug":"spring aop","date":"2018-03-11T15:08:14.000Z","updated":"2018-03-11T15:24:10.000Z","comments":true,"path":"2018/03/11/spring aop/","link":"","permalink":"https://killgc.github.io/shortfeng/2018/03/11/spring aop/","excerpt":"","text":"spring aop @Transactional 在需要事务管理的地方加@Transactional 注解。@Transactional 注解可以被应用于接口定义和接口方法、类定义和类的 public 方法上。 @Transactional 注解只能应用到 public 可见度的方法上。 如果你在 protected、private 或者 package-visible 的方法上使用 @Transactional 注解，它也不会报错， 但是这个被注解的方法将不会展示已配置的事务设置。 注意仅仅 @Transactional 注解的出现不足于开启事务行为，它仅仅 是一种元数据。必须在配置文件中使用配置元素，才真正开启了事务行为。 通过 元素的 “proxy-target-class” 属性值来控制是基于接口的还是基于类的代理被创建。如果 “proxy-target-class” 属值被设置为 “true”，那么基于类的代理将起作用（这时需要CGLIB库cglib.jar在CLASSPATH中）。如果 “proxy-target-class” 属值被设置为 “false” 或者这个属性被省略，那么标准的JDK基于接口的代理将起作用。 Spring团队建议在具体的类（或类的方法）上使用 @Transactional 注解，而不要使用在类所要实现的任何接口上。在接口上使用 @Transactional 注解，只能当你设置了基于接口的代理时它才生效。因为注解是 不能继承 的，这就意味着如果正在使用基于类的代理时，那么事务的设置将不能被基于类的代理所识别，而且对象也将不会被事务代理所包装。 @Transactional 的事务开启 ，或者是基于接口的 或者是基于类的代理被创建。所以在同一个类中一个方法调用另一个方法有事务的方法，事务是不会起作用的。 1、@Transactional 只能应用到 public 方法才有效 2、避免 Spring 的 AOP 的自调用问题 在 Spring 的 AOP 代理下，只有目标方法由外部调用，目标方法才由 Spring 生成的代理对象来管理，这会造成自调用问题。若同一类中的其他没有@Transactional 注解的方法内部调用有@Transactional 注解的方法，有@Transactional 注解的方法的事务被忽略，不会发生回滚。 123456789101112@Servicepublic class OrderService &#123; private void insert() &#123; insertOrder(); &#125; @Transactional public void insertOrder() &#123; //insert log info //insertOrder //updateAccount &#125;&#125;","categories":[],"tags":[]},{"title":"拦截器","slug":"拦截器","date":"2018-03-07T09:47:55.000Z","updated":"2018-03-08T11:27:38.000Z","comments":true,"path":"2018/03/07/拦截器/","link":"","permalink":"https://killgc.github.io/shortfeng/2018/03/07/拦截器/","excerpt":"","text":"拦截器标签（空格分隔）： java 拦截器 过滤器 拦截器 过滤器 监听器 拦截器与过滤器的区别 过滤器可以简单的理解为“取你所想取”，过滤器关注的是web请求； 拦截器可以简单的理解为“拒你所想拒”，拦截器关注的是方法调用，比如拦截敏感词汇 拦截器是基于java反射机制的，而过滤器是基于函数回调。 拦截器不依赖于Servlet容器，而过滤器依赖于servlet容器。 拦截器只能对action请求起作用，而过滤器可以对几乎所有的请求起作用。 拦截器可以访问action上下文，值栈里的对象，而过滤器不能。在Action的生命周期周，拦截器可以被多次调用，而过滤器只能在容器初始化的时候被调用一次。 执行顺序 ：过滤前 - 拦截前 - Action处理 - 拦截后 - 过滤后过滤器是横向过程 你传入的request,response提前过滤掉一些信息，或者提前设置一些参数，然后再传入servlet或者struts的action进行业务逻辑，比如过滤掉非法url（不是login.do的地址请求，如果用户没有登陆都过滤掉）,或者在传入servlet或者struts的action前统一设置字符集，或者去除掉一些非法字符（聊天室经常用到的，一些骂人的话）。filter 流程是线性的，url传来之后，检查之后 拦截器拦截器的原理是基于jdk动态代理，需实现HandlerInterceptor接口或继承HandlerInterceptorAdapter类 1234567891011121314151617181920212223242526272829303132333435363738394041HandlerInterceptor接口：/*** preHandle方法是进行处理器拦截用的，顾名思义，该方法将在Controller处理之前进行调用，* SpringMVC中的Interceptor拦截器是链式的，可以同时存在多个Interceptor，* 然后SpringMVC会根据声明的前后顺序一个接一个的执行，* 而且所有的Interceptor中的preHandle方法都会在Controller方法调用之前调用。* SpringMVC的这种Interceptor链式结构也是可以进行中断的，* 这种中断方式是令preHandle的返回值为false，当preHandle的返回值为false的时候整个请求就结束了。*/@Overridepublic boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)throws Exception &#123;return true;&#125;/*** 这个方法只会在当前这个Interceptor的preHandle方法返回值为true的时候才会执行。* postHandle是进行处理器拦截用的，它的执行时间是在处理器进行处理之 后， 也就是在Controller的方法调用之后执行，* 但是它会在DispatcherServlet进行视图的渲染之前执行，也就是说在这个方法中你可以对ModelAndView进行操作。* 这个方法的链式结构跟正常访问的方向是相反的，也就是说先声明的Interceptor拦截器该方法反而会后调用，* 这跟Struts2里面的拦截器的执行过程有点像，* 只是Struts2里面的intercept方法中要手动的调用ActionInvocation的invoke方法，* Struts2中调用ActionInvocation的invoke方法就是调用下一个Interceptor或者是调用action，* 然后要在Interceptor之前调用的内容都写在调用invoke之前，要在Interceptor之后调用的内容都写在调用invoke方法之后。*/@Overridepublic void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)throws Exception &#123;&#125;/*** 该方法也是需要当前对应的Interceptor的preHandle方法的返回值为true时才会执行。* 该方法将在整个请求完成之后，也就是DispatcherServlet渲染了视图执行， 这个方法的主要作用是用于清理资源的，*/@Overridepublic void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)throws Exception &#123;&#125; 配置123456789101112131415&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"xmlns:mvc=\"http://www.springframework.org/schema/mvc\"xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.1.xsdhttp://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd\"&gt;&lt;mvc:interceptors&gt;&lt;!-- 日志拦截器 --&gt;&lt;mvc:interceptor&gt;&lt;mvc:mapping path=\"/**\" /&gt;&lt;mvc:exclude-mapping path=\"/static/**\" /&gt;&lt;bean class=\"拦截器java代码路径\" /&gt;&lt;/mvc:interceptor&gt;&lt;/mvc:interceptors&gt;&lt;/beans&gt; 工作流程一个拦截器，只有preHandle方法返回true，postHandle、afterCompletion才有可能被执行；如果preHandle方法返回false，则该拦截器的postHandle、afterCompletion必然不会被执行。 假设我们有两个拦截器，例如叫Interceptor1和Interceptor2，当一个请求过来，正常的流程和中断的流程分别如下。 正常流程注意两个拦截器在执行preHandle方法和执行postHandle、afterCompletion方法时，顺序是颠倒的。 1234567891011121314151. Interceptor1.preHandle2. Interceptor2.preHandle3. Controller处理请求4. Interceptor2.postHandle5. Interceptor1.postHandle6. 渲染视图7. Interceptor2.afterCompletion8. Interceptor1.afterCompletion 中断流程假设执行Interceptor2.preHandle中报错，那么流程被中断，之前被执行过的拦截器的afterCompletion仍然会执行。在本例中，即执行了Interceptor1.afterCompletion。 12345671. Interceptor1.preHandle2. Interceptor2.preHandle//中间流程被中断，不再执行3. Interceptor1.afterCompletion 与过滤器共存时的执行顺序拦截器是在DispatcherServlet这个servlet中执行的，因此所有的请求最先进入Filter，最后离开Filter。其顺序如下。 Filter-&gt;Interceptor.preHandle-&gt;Handler-&gt;Interceptor.postHandle-&gt;Interceptor.afterCompletion-&gt;Filter 应用场景拦截器本质上是面向切面编程（AOP），符合横切关注点的功能都可以放在拦截器中来实现，主要的应用场景包括： 登录验证，判断用户是否登录。权限验证，判断用户是否有权限访问资源。日志记录，记录请求日志，以便统计请求访问量。处理cookie、本地化、国际化、主题等。性能监控，监控请求处理时长等。 spring boot配置拦截器为了使自定义的拦截器生效，需要注册拦截器到spring容器中，具体的做法是继承WebMvcConfigurerAdapter类，覆盖其addInterceptors(InterceptorRegistry registry)方法。最后别忘了把Bean注册到Spring容器中，可以选择@Component 或者 @Configuration 123456789101112131415@Componentpublic class InterceptorConfiguration extends WebMvcConfigurerAdapter&#123;@Overridepublic void addInterceptors(InterceptorRegistry registry) &#123;// 注册拦截器InterceptorRegistration ir = registry.addInterceptor(new LoginInterceptor());// 配置拦截的路径ir.addPathPatterns(&quot;/**&quot;);// 配置不拦截的路径ir.excludePathPatterns(&quot;/**.html&quot;);// 还可以在这里注册其它的拦截器//registry.addInterceptor(new OtherInterceptor()).addPathPatterns(&quot;/**&quot;);&#125;&#125;","categories":[],"tags":[]},{"title":"JAVA动态代理","slug":"动态代理","date":"2018-02-09T09:47:55.000Z","updated":"2018-03-11T13:55:41.000Z","comments":true,"path":"2018/02/09/动态代理/","link":"","permalink":"https://killgc.github.io/shortfeng/2018/02/09/动态代理/","excerpt":"","text":"JAVA动态代理 静态代理的代理关系在编译时就确定了，而动态代理的代理关系是在编译期确定的。静态代理实现简单，适合于代理类较少且确定的情况，而动态代理则给我们提供了更大的灵活性 JDK原生动态代理是Java原生支持的，不需要任何外部依赖，但是它只能基于接口进行代理；CGLIB通过继承的方式进行代理，无论目标对象有没有实现接口都可以代理，但是无法处理final、private方法 CGLib创建的动态代理对象性能比JDK创建的动态代理对象的性能高不少，但是CGLib在创建代理对象时所花费的时间却比JDK多得多，所以对于单例的对象，因为无需频繁创建对象，用CGLib合适，反之，使用JDK方式要更为合适一些 jdk采用反射机制调用委托类的方法，cglib采用类似索引的方式直接调用委托类方法 标签（空格分隔）： jdk动态代理 cglib jdk动态代理 jdk动态代理机制中，有两个重要的类或接口，一个是Proxy，另一个是InvocationHandler Proxy类Proxy类是用来动态创建一个代理对象，经常使用newProxyInstance静态方法12345public static Object newProxyInstance(ClassLoader loader,Class&lt;?&gt;[] interfaces,InvocationHandler h) throws IllegalArgumentException参数：loader 类加载器interfaces 真实类所拥有的所有接口的数组h 调用处理器对象 InvocationHandler接口InvocationHandler接口只有唯一一个invoke方法12345public Object invoke(Object proxy, Method method, Object[] args) throws Throwable;参数：proxy 代理类对象method 调用真实类对象某个方法对应的method对象args 调用真实类对象某个方法传人的参数 示例1、主题接口 123456package com.example.ford.proxy;public interface Subject &#123; String sayHello(String name); String sayGoodBye();&#125; 2、 被代理类 12345678910111213package com.example.ford.proxy;public class RealSubject implements Subject&#123; @Override public String sayHello(String name) &#123; return \"hello \"+name; &#125; @Override public String sayGoodBye() &#123; return \" good bye\"; &#125;&#125; 3、调用处理器 123456789101112131415161718192021package com.example.ford.proxy;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;public class TestInvocationHandler implements InvocationHandler&#123; private Subject subject; public TestInvocationHandler(Subject subject)&#123; this.subject = subject; &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; System.out.println(proxy.getClass()); System.out.println(\"开始执行 \"+method.getName()); Object returnValue = method.invoke(subject,args); System.out.println(\"结束执行 \"+method.getName()); return returnValue; &#125;&#125; 3、测试 12345678910111213141516171819package com.example.ford.proxy;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Proxy;public class TestMain &#123; public static void main(String[] args) &#123; Subject subject = new RealSubject(); InvocationHandler handler = new TestInvocationHandler(subject); Class cls = subject.getClass(); ClassLoader loader = cls.getClassLoader(); Class[] interfaces = cls.getInterfaces(); Subject proxy = (Subject) Proxy.newProxyInstance(loader, interfaces, handler); String returnValue1 = proxy.sayHello(\"changfeng\"); System.out.println(returnValue1); String returnValue2 = proxy.sayGoodBye(); System.out.println(returnValue2); &#125;&#125; 测试结果 12345678class com.sun.proxy.$Proxy0开始执行 sayHello结束执行 sayHellohello changfengclass com.sun.proxy.$Proxy0开始执行 sayGoodBye结束执行 sayGoodBye good bye 原理分析生成代理类类文件： 1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.example.ford.proxy;import sun.misc.ProxyGenerator;import java.io.File;import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.IOException;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Proxy;public class JDKProxyTest &#123; public static void main(String[] args)&#123; Subject subject = new RealSubject(); InvocationHandler handler = new TestInvocationHandler(subject); Class cls = subject.getClass(); ClassLoader loader = cls.getClassLoader(); Class[] interfaces = cls.getInterfaces(); Subject proxy = (Subject) Proxy.newProxyInstance(loader, interfaces, handler); createProxyClassFile(); &#125; private static void createProxyClassFile()&#123; String name = \"ProxySubject\"; byte[] data = ProxyGenerator.generateProxyClass(name,new Class[]&#123;Subject.class&#125;); FileOutputStream out =null; try &#123; out = new FileOutputStream(name+\".class\"); System.out.println((new File(\"hello\")).getAbsolutePath()); out.write(data); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;finally &#123; if(null!=out) try &#123; out.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 利用jd-gui反编译代理类class文件，可以发现最终生成的代理类继承Proxy类、实现Subject接口,代理类实现了Subject接口的sayHello方法、sayGoodBye方法,在实现Subject接口方法的内部，通过反射调用了InvocationHandlerImpl的invoke方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122import com.example.ford.proxy.Subject;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;import java.lang.reflect.UndeclaredThrowableException;public final class ProxySubject extends Proxy implements Subject&#123; private static Method m1; private static Method m3; private static Method m2; private static Method m4; private static Method m0; public ProxySubject(InvocationHandler paramInvocationHandler) &#123; super(paramInvocationHandler); &#125; public final boolean equals(Object paramObject) &#123; try &#123; return ((Boolean)this.h.invoke(this, m1, new Object[] &#123; paramObject &#125;)).booleanValue(); &#125; catch (Error|RuntimeException localError) &#123; throw localError; &#125; catch (Throwable localThrowable) &#123; throw new UndeclaredThrowableException(localThrowable); &#125; &#125; public final String sayHello(String paramString) &#123; try &#123; return (String)this.h.invoke(this, m3, new Object[] &#123; paramString &#125;); &#125; catch (Error|RuntimeException localError) &#123; throw localError; &#125; catch (Throwable localThrowable) &#123; throw new UndeclaredThrowableException(localThrowable); &#125; &#125; public final String toString() &#123; try &#123; return (String)this.h.invoke(this, m2, null); &#125; catch (Error|RuntimeException localError) &#123; throw localError; &#125; catch (Throwable localThrowable) &#123; throw new UndeclaredThrowableException(localThrowable); &#125; &#125; public final String sayGoodBye() &#123; try &#123; return (String)this.h.invoke(this, m4, null); &#125; catch (Error|RuntimeException localError) &#123; throw localError; &#125; catch (Throwable localThrowable) &#123; throw new UndeclaredThrowableException(localThrowable); &#125; &#125; public final int hashCode() &#123; try &#123; return ((Integer)this.h.invoke(this, m0, null)).intValue(); &#125; catch (Error|RuntimeException localError) &#123; throw localError; &#125; catch (Throwable localThrowable) &#123; throw new UndeclaredThrowableException(localThrowable); &#125; &#125; static &#123; try &#123; m1 = Class.forName(\"java.lang.Object\").getMethod(\"equals\", new Class[] &#123; Class.forName(\"java.lang.Object\") &#125;); m3 = Class.forName(\"com.example.ford.proxy.Subject\").getMethod(\"sayHello\", new Class[] &#123; Class.forName(\"java.lang.String\") &#125;); m2 = Class.forName(\"java.lang.Object\").getMethod(\"toString\", new Class[0]); m4 = Class.forName(\"com.example.ford.proxy.Subject\").getMethod(\"sayGoodBye\", new Class[0]); m0 = Class.forName(\"java.lang.Object\").getMethod(\"hashCode\", new Class[0]); return; &#125; catch (NoSuchMethodException localNoSuchMethodException) &#123; throw new NoSuchMethodError(localNoSuchMethodException.getMessage()); &#125; catch (ClassNotFoundException localClassNotFoundException) &#123; throw new NoClassDefFoundError(localClassNotFoundException.getMessage()); &#125; &#125;&#125; 注意:对于从Object中继承的方法，JDK Proxy会把hashCode()、equals()、toString()这三个非接口方法转发给InvocationHandler，其余的Object方法则不会转发 cglib动态代理 cglib动态代理必须实现MethodInterceptor接口 MethodInterceptor接口1234567891011package org.springframework.cglib.proxy;import java.lang.reflect.Method;public interface MethodInterceptor extends Callback &#123; Object intercept(Object var1, Method var2, Object[] var3, MethodProxy var4) throws Throwable; 参数1 代理对象 参数2 方法对象 参数3 方法参数 参数4 方法对应的&#125; 示例12345678910111213141516171819202122232425262728293031323334353637package com.example.ford.proxy;import org.springframework.cglib.proxy.Enhancer;import org.springframework.cglib.proxy.MethodInterceptor;import org.springframework.cglib.proxy.MethodProxy;import java.lang.reflect.Method;public class CglibProxy implements MethodInterceptor&#123; private Enhancer enhancer = new Enhancer(); public Object getProxy(Class cls)&#123; enhancer.setSuperclass(cls); enhancer.setCallback(this); return enhancer.create(); &#125; @Override public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable &#123; System.out.println(o.getClass()); System.out.println(\"开始执行 \"+method.getName()); //我们一般使用proxy.invokeSuper(obj,args)方法。这个很好理解，就是执行原始类的方法。还有一个方法proxy.invoke(obj,args)，这是执行生成子类的方法。 //如果传入的obj就是子类的话，会发生内存溢出，因为子类的方法不停地进入intercept方法，而这个方法又去调用子类的方法，两个方法直接循环调用了。 Object returnValue = methodProxy.invokeSuper(o,objects); //Object returnValue = methodProxy.invoke(o,objects); System.out.println(\"结束执行 \"+method.getName()); return returnValue; &#125; public static void main(String[] args)&#123; CglibProxy cglibProxy = new CglibProxy(); RealSubject realSubject = (RealSubject)cglibProxy.getProxy(RealSubject.class); Object returnValue1 = realSubject.sayHello(\"changfeng\"); System.out.println(returnValue1); Object returnValue2 = realSubject.sayGoodBye(); System.out.println(returnValue2); &#125;&#125; 注意：对于从Object中继承的方法，CGLIB代理也会进行代理，如hashCode()、equals()、toString()等，但是getClass()、wait()等方法不会，因为它是final方法，CGLIB无法代理 注意：既然是继承就不得不考虑final的问题。我们知道final类型不能有子类，所以CGLIB不能代理final类型，遇到这种情况会抛出类似如下异常： java.lang.IllegalArgumentException: Cannot subclass final class cglib.HelloConcrete 注意：同样的，final方法是不能重载的，所以也不能通过CGLIB代理，遇到这种情况不会抛异常，而是会跳过final方法只代理其他方法。 源码分析通过以下方式可以生成代理类class文件System.setProperty(DebuggingClassWriter.DEBUG_LOCATION_PROPERTY, “C:\\\\Code\\\\whywhy\\\\target\\\\classes\\\\zzzzzz”) 用jd-gui反编译代理类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460package com.example.ford.proxy;import java.lang.reflect.Method;import org.springframework.cglib.proxy.Callback;import org.springframework.cglib.proxy.Factory;import org.springframework.cglib.proxy.MethodInterceptor;import org.springframework.cglib.proxy.MethodProxy;public class RealSubject$$EnhancerByCGLIB$$6a387257 extends RealSubject implements Factory&#123; private boolean CGLIB$BOUND; public static Object CGLIB$FACTORY_DATA; private static final ThreadLocal CGLIB$THREAD_CALLBACKS; private static final Callback[] CGLIB$STATIC_CALLBACKS; private MethodInterceptor CGLIB$CALLBACK_0; private static Object CGLIB$CALLBACK_FILTER; private static final Method CGLIB$sayHello$0$Method; private static final MethodProxy CGLIB$sayHello$0$Proxy; private static final Object[] CGLIB$emptyArgs; private static final Method CGLIB$sayGoodBye$1$Method; private static final MethodProxy CGLIB$sayGoodBye$1$Proxy; private static final Method CGLIB$equals$2$Method; private static final MethodProxy CGLIB$equals$2$Proxy; private static final Method CGLIB$toString$3$Method; private static final MethodProxy CGLIB$toString$3$Proxy; private static final Method CGLIB$hashCode$4$Method; private static final MethodProxy CGLIB$hashCode$4$Proxy; private static final Method CGLIB$clone$5$Method; private static final MethodProxy CGLIB$clone$5$Proxy; /* Error */ static void CGLIB$STATICHOOK1() &#123; // Byte code: // 0: new 22 java/lang/ThreadLocal // 3: dup // 4: invokespecial 25 java/lang/ThreadLocal:&lt;init&gt; ()V // 7: putstatic 27 com/example/ford/proxy/RealSubject$$EnhancerByCGLIB$$6a387257:CGLIB$THREAD_CALLBACKS Ljava/lang/ThreadLocal; // 10: iconst_0 // 11: anewarray 48 java/lang/Object // 14: putstatic 69 com/example/ford/proxy/RealSubject$$EnhancerByCGLIB$$6a387257:CGLIB$emptyArgs [Ljava/lang/Object; // 17: ldc -108 // 19: invokestatic 154 java/lang/Class:forName (Ljava/lang/String;)Ljava/lang/Class; // 22: astore_0 // 23: iconst_4 // 24: anewarray 58 java/lang/String // 27: dup // 28: iconst_0 // 29: ldc -101 // 31: aastore // 32: dup // 33: iconst_1 // 34: ldc -100 // 36: aastore // 37: dup // 38: iconst_2 // 39: ldc -99 // 41: aastore // 42: dup // 43: iconst_3 // 44: ldc -98 // 46: aastore // 47: ldc -96 // 49: invokestatic 154 java/lang/Class:forName (Ljava/lang/String;)Ljava/lang/Class; // 52: dup // 53: astore_1 // 54: invokevirtual 164 java/lang/Class:getDeclaredMethods ()[Ljava/lang/reflect/Method; // 57: invokestatic 170 org/springframework/cglib/core/ReflectUtils:findMethods ([Ljava/lang/String;[Ljava/lang/reflect/Method;)[Ljava/lang/reflect/Method; // 60: dup // 61: iconst_0 // 62: aaload // 63: putstatic 46 com/example/ford/proxy/RealSubject$$EnhancerByCGLIB$$6a387257:CGLIB$sayHello$0$Method Ljava/lang/reflect/Method; // 66: aload_1 // 67: aload_0 // 68: ldc -100 // 70: ldc -101 // 72: ldc -85 // 74: invokestatic 177 org/springframework/cglib/proxy/MethodProxy:create (Ljava/lang/Class;Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)Lorg/springframework/cglib/proxy/MethodProxy; // 77: putstatic 50 com/example/ford/proxy/RealSubject$$EnhancerByCGLIB$$6a387257:CGLIB$sayHello$0$Proxy Lorg/springframework/cglib/proxy/MethodProxy; // 80: dup // 81: iconst_1 // 82: aaload // 83: putstatic 67 com/example/ford/proxy/RealSubject$$EnhancerByCGLIB$$6a387257:CGLIB$sayGoodBye$1$Method Ljava/lang/reflect/Method; // 86: aload_1 // 87: aload_0 // 88: ldc -98 // 90: ldc -99 // 92: ldc -78 // 94: invokestatic 177 org/springframework/cglib/proxy/MethodProxy:create (Ljava/lang/Class;Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)Lorg/springframework/cglib/proxy/MethodProxy; // 97: putstatic 71 com/example/ford/proxy/RealSubject$$EnhancerByCGLIB$$6a387257:CGLIB$sayGoodBye$1$Proxy Lorg/springframework/cglib/proxy/MethodProxy; // 100: pop // 101: bipush 8 // 103: anewarray 58 java/lang/String // 106: dup // 107: iconst_0 // 108: ldc -77 // 110: aastore // 111: dup // 112: iconst_1 // 113: ldc -76 // 115: aastore // 116: dup // 117: iconst_2 // 118: ldc -75 // 120: aastore // 121: dup // 122: iconst_3 // 123: ldc -98 // 125: aastore // 126: dup // 127: iconst_4 // 128: ldc -74 // 130: aastore // 131: dup // 132: iconst_5 // 133: ldc -73 // 135: aastore // 136: dup // 137: bipush 6 // 139: ldc -72 // 141: aastore // 142: dup // 143: bipush 7 // 145: ldc -71 // 147: aastore // 148: ldc -69 // 150: invokestatic 154 java/lang/Class:forName (Ljava/lang/String;)Ljava/lang/Class; // 153: dup // 154: astore_1 // 155: invokevirtual 164 java/lang/Class:getDeclaredMethods ()[Ljava/lang/reflect/Method; // 158: invokestatic 170 org/springframework/cglib/core/ReflectUtils:findMethods ([Ljava/lang/String;[Ljava/lang/reflect/Method;)[Ljava/lang/reflect/Method; // 161: dup // 162: iconst_0 // 163: aaload // 164: putstatic 80 com/example/ford/proxy/RealSubject$$EnhancerByCGLIB$$6a387257:CGLIB$equals$2$Method Ljava/lang/reflect/Method; // 167: aload_1 // 168: aload_0 // 169: ldc -76 // 171: ldc -77 // 173: ldc -68 // 175: invokestatic 177 org/springframework/cglib/proxy/MethodProxy:create (Ljava/lang/Class;Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)Lorg/springframework/cglib/proxy/MethodProxy; // 178: putstatic 82 com/example/ford/proxy/RealSubject$$EnhancerByCGLIB$$6a387257:CGLIB$equals$2$Proxy Lorg/springframework/cglib/proxy/MethodProxy; // 181: dup // 182: iconst_1 // 183: aaload // 184: putstatic 96 com/example/ford/proxy/RealSubject$$EnhancerByCGLIB$$6a387257:CGLIB$toString$3$Method Ljava/lang/reflect/Method; // 187: aload_1 // 188: aload_0 // 189: ldc -98 // 191: ldc -75 // 193: ldc -67 // 195: invokestatic 177 org/springframework/cglib/proxy/MethodProxy:create (Ljava/lang/Class;Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)Lorg/springframework/cglib/proxy/MethodProxy; // 198: putstatic 98 com/example/ford/proxy/RealSubject$$EnhancerByCGLIB$$6a387257:CGLIB$toString$3$Proxy Lorg/springframework/cglib/proxy/MethodProxy; // 201: dup // 202: iconst_2 // 203: aaload // 204: putstatic 107 com/example/ford/proxy/RealSubject$$EnhancerByCGLIB$$6a387257:CGLIB$hashCode$4$Method Ljava/lang/reflect/Method; // 207: aload_1 // 208: aload_0 // 209: ldc -73 // 211: ldc -74 // 213: ldc -66 // 215: invokestatic 177 org/springframework/cglib/proxy/MethodProxy:create (Ljava/lang/Class;Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)Lorg/springframework/cglib/proxy/MethodProxy; // 218: putstatic 109 com/example/ford/proxy/RealSubject$$EnhancerByCGLIB$$6a387257:CGLIB$hashCode$4$Proxy Lorg/springframework/cglib/proxy/MethodProxy; // 221: dup // 222: iconst_3 // 223: aaload // 224: putstatic 125 com/example/ford/proxy/RealSubject$$EnhancerByCGLIB$$6a387257:CGLIB$clone$5$Method Ljava/lang/reflect/Method; // 227: aload_1 // 228: aload_0 // 229: ldc -71 // 231: ldc -72 // 233: ldc -65 // 235: invokestatic 177 org/springframework/cglib/proxy/MethodProxy:create (Ljava/lang/Class;Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)Lorg/springframework/cglib/proxy/MethodProxy; // 238: putstatic 127 com/example/ford/proxy/RealSubject$$EnhancerByCGLIB$$6a387257:CGLIB$clone$5$Proxy Lorg/springframework/cglib/proxy/MethodProxy; // 241: pop // 242: return // 243: athrow &#125; final String CGLIB$sayHello$0(String paramString) &#123; return super.sayHello(paramString); &#125; public final String sayHello(String paramString) &#123; MethodInterceptor tmp4_1 = this.CGLIB$CALLBACK_0; if (tmp4_1 == null) &#123; tmp4_1; CGLIB$BIND_CALLBACKS(this); &#125; MethodInterceptor tmp17_14 = this.CGLIB$CALLBACK_0; if (tmp17_14 != null) &#123; return (String)tmp17_14.intercept(this, CGLIB$sayHello$0$Method, new Object[] &#123; paramString &#125;, CGLIB$sayHello$0$Proxy); &#125; return super.sayHello(paramString); &#125; final String CGLIB$sayGoodBye$1() &#123; return super.sayGoodBye(); &#125; public final String sayGoodBye() &#123; MethodInterceptor tmp4_1 = this.CGLIB$CALLBACK_0; if (tmp4_1 == null) &#123; tmp4_1; CGLIB$BIND_CALLBACKS(this); &#125; MethodInterceptor tmp17_14 = this.CGLIB$CALLBACK_0; if (tmp17_14 != null) &#123; return (String)tmp17_14.intercept(this, CGLIB$sayGoodBye$1$Method, CGLIB$emptyArgs, CGLIB$sayGoodBye$1$Proxy); &#125; return super.sayGoodBye(); &#125; final boolean CGLIB$equals$2(Object paramObject) &#123; return super.equals(paramObject); &#125; public final boolean equals(Object paramObject) &#123; MethodInterceptor tmp4_1 = this.CGLIB$CALLBACK_0; if (tmp4_1 == null) &#123; tmp4_1; CGLIB$BIND_CALLBACKS(this); &#125; MethodInterceptor tmp17_14 = this.CGLIB$CALLBACK_0; if (tmp17_14 != null) &#123; Object tmp41_36 = tmp17_14.intercept(this, CGLIB$equals$2$Method, new Object[] &#123; paramObject &#125;, CGLIB$equals$2$Proxy); tmp41_36; return tmp41_36 == null ? false : ((Boolean)tmp41_36).booleanValue(); &#125; return super.equals(paramObject); &#125; final String CGLIB$toString$3() &#123; return super.toString(); &#125; public final String toString() &#123; MethodInterceptor tmp4_1 = this.CGLIB$CALLBACK_0; if (tmp4_1 == null) &#123; tmp4_1; CGLIB$BIND_CALLBACKS(this); &#125; MethodInterceptor tmp17_14 = this.CGLIB$CALLBACK_0; if (tmp17_14 != null) &#123; return (String)tmp17_14.intercept(this, CGLIB$toString$3$Method, CGLIB$emptyArgs, CGLIB$toString$3$Proxy); &#125; return super.toString(); &#125; final int CGLIB$hashCode$4() &#123; return super.hashCode(); &#125; public final int hashCode() &#123; MethodInterceptor tmp4_1 = this.CGLIB$CALLBACK_0; if (tmp4_1 == null) &#123; tmp4_1; CGLIB$BIND_CALLBACKS(this); &#125; MethodInterceptor tmp17_14 = this.CGLIB$CALLBACK_0; if (tmp17_14 != null) &#123; Object tmp36_31 = tmp17_14.intercept(this, CGLIB$hashCode$4$Method, CGLIB$emptyArgs, CGLIB$hashCode$4$Proxy); tmp36_31; return tmp36_31 == null ? 0 : ((Number)tmp36_31).intValue(); &#125; return super.hashCode(); &#125; final Object CGLIB$clone$5() throws CloneNotSupportedException &#123; return super.clone(); &#125; protected final Object clone() throws CloneNotSupportedException &#123; MethodInterceptor tmp4_1 = this.CGLIB$CALLBACK_0; if (tmp4_1 == null) &#123; tmp4_1; CGLIB$BIND_CALLBACKS(this); &#125; MethodInterceptor tmp17_14 = this.CGLIB$CALLBACK_0; if (tmp17_14 != null) &#123; return tmp17_14.intercept(this, CGLIB$clone$5$Method, CGLIB$emptyArgs, CGLIB$clone$5$Proxy); &#125; return super.clone(); &#125; /* Error */ public static MethodProxy CGLIB$findMethodProxy(org.springframework.cglib.core.Signature arg0) &#123; // Byte code: // 0: aload_0 // 1: invokevirtual 130 java/lang/Object:toString ()Ljava/lang/String; // 4: dup // 5: invokevirtual 131 java/lang/Object:hashCode ()I // 8: lookupswitch default:+132-&gt;140, -1816210712:+60-&gt;68, -508378822:+72-&gt;80, 1577955665:+84-&gt;92, 1826985398:+96-&gt;104, 1913648695:+108-&gt;116, 1984935277:+120-&gt;128 // 68: ldc -123 // 70: invokevirtual 134 java/lang/Object:equals (Ljava/lang/Object;)Z // 73: ifeq +68 -&gt; 141 // 76: getstatic 50 com/example/ford/proxy/RealSubject$$EnhancerByCGLIB$$6a387257:CGLIB$sayHello$0$Proxy Lorg/springframework/cglib/proxy/MethodProxy; // 79: areturn // 80: ldc -120 // 82: invokevirtual 134 java/lang/Object:equals (Ljava/lang/Object;)Z // 85: ifeq +56 -&gt; 141 // 88: getstatic 127 com/example/ford/proxy/RealSubject$$EnhancerByCGLIB$$6a387257:CGLIB$clone$5$Proxy Lorg/springframework/cglib/proxy/MethodProxy; // 91: areturn // 92: ldc -118 // 94: invokevirtual 134 java/lang/Object:equals (Ljava/lang/Object;)Z // 97: ifeq +44 -&gt; 141 // 100: getstatic 71 com/example/ford/proxy/RealSubject$$EnhancerByCGLIB$$6a387257:CGLIB$sayGoodBye$1$Proxy Lorg/springframework/cglib/proxy/MethodProxy; // 103: areturn // 104: ldc -116 // 106: invokevirtual 134 java/lang/Object:equals (Ljava/lang/Object;)Z // 109: ifeq +32 -&gt; 141 // 112: getstatic 82 com/example/ford/proxy/RealSubject$$EnhancerByCGLIB$$6a387257:CGLIB$equals$2$Proxy Lorg/springframework/cglib/proxy/MethodProxy; // 115: areturn // 116: ldc -114 // 118: invokevirtual 134 java/lang/Object:equals (Ljava/lang/Object;)Z // 121: ifeq +20 -&gt; 141 // 124: getstatic 98 com/example/ford/proxy/RealSubject$$EnhancerByCGLIB$$6a387257:CGLIB$toString$3$Proxy Lorg/springframework/cglib/proxy/MethodProxy; // 127: areturn // 128: ldc -112 // 130: invokevirtual 134 java/lang/Object:equals (Ljava/lang/Object;)Z // 133: ifeq +8 -&gt; 141 // 136: getstatic 109 com/example/ford/proxy/RealSubject$$EnhancerByCGLIB$$6a387257:CGLIB$hashCode$4$Proxy Lorg/springframework/cglib/proxy/MethodProxy; // 139: areturn // 140: pop // 141: aconst_null // 142: areturn &#125; public RealSubject$$EnhancerByCGLIB$$6a387257() &#123; CGLIB$BIND_CALLBACKS(this); &#125; public static void CGLIB$SET_THREAD_CALLBACKS(Callback[] paramArrayOfCallback) &#123; CGLIB$THREAD_CALLBACKS.set(paramArrayOfCallback); &#125; public static void CGLIB$SET_STATIC_CALLBACKS(Callback[] paramArrayOfCallback) &#123; CGLIB$STATIC_CALLBACKS = paramArrayOfCallback; &#125; private static final void CGLIB$BIND_CALLBACKS(Object paramObject) &#123; 6a387257 local6a387257 = (6a387257)paramObject; if (!local6a387257.CGLIB$BOUND) &#123; local6a387257.CGLIB$BOUND = true; Object tmp23_20 = CGLIB$THREAD_CALLBACKS.get(); if (tmp23_20 == null) &#123; tmp23_20; CGLIB$STATIC_CALLBACKS; &#125; local6a387257.CGLIB$CALLBACK_0 = (tmp31_28 == null ? tmp31_28 : (MethodInterceptor)((Callback[])tmp23_20)[0]); &#125; &#125; public Object newInstance(Callback[] paramArrayOfCallback) &#123; CGLIB$SET_THREAD_CALLBACKS(paramArrayOfCallback); CGLIB$SET_THREAD_CALLBACKS(null); return new 6a387257(); &#125; public Object newInstance(Callback paramCallback) &#123; CGLIB$SET_THREAD_CALLBACKS(new Callback[] &#123; paramCallback &#125;); CGLIB$SET_THREAD_CALLBACKS(null); return new 6a387257(); &#125; /* Error */ public Object newInstance(Class[] arg1, Object[] arg2, Callback[] arg3) &#123; // Byte code: // 0: aload_3 // 1: invokestatic 210 com/example/ford/proxy/RealSubject$$EnhancerByCGLIB$$6a387257:CGLIB$SET_THREAD_CALLBACKS ([Lorg/springframework/cglib/proxy/Callback;)V // 4: new 2 com/example/ford/proxy/RealSubject$$EnhancerByCGLIB$$6a387257 // 7: dup // 8: aload_1 // 9: dup // 10: arraylength // 11: tableswitch default:+24-&gt;35, 0:+17-&gt;28 // 28: pop // 29: invokespecial 211 com/example/ford/proxy/RealSubject$$EnhancerByCGLIB$$6a387257:&lt;init&gt; ()V // 32: goto +17 -&gt; 49 // 35: goto +3 -&gt; 38 // 38: pop // 39: new 217 java/lang/IllegalArgumentException // 42: dup // 43: ldc -37 // 45: invokespecial 222 java/lang/IllegalArgumentException:&lt;init&gt; (Ljava/lang/String;)V // 48: athrow // 49: aconst_null // 50: invokestatic 210 com/example/ford/proxy/RealSubject$$EnhancerByCGLIB$$6a387257:CGLIB$SET_THREAD_CALLBACKS ([Lorg/springframework/cglib/proxy/Callback;)V // 53: areturn &#125; public Callback getCallback(int paramInt) &#123; CGLIB$BIND_CALLBACKS(this); switch (paramInt) &#123; case 0: break; &#125; return null; &#125; public void setCallback(int paramInt, Callback paramCallback) &#123; switch (paramInt) &#123; case 0: this.CGLIB$CALLBACK_0 = ((MethodInterceptor)paramCallback); break; &#125; &#125; public Callback[] getCallbacks() &#123; CGLIB$BIND_CALLBACKS(this); return new Callback[] &#123; this.CGLIB$CALLBACK_0 &#125;; &#125; public void setCallbacks(Callback[] paramArrayOfCallback) &#123; this.CGLIB$CALLBACK_0 = ((MethodInterceptor)paramArrayOfCallback[0]); &#125; static &#123;&#125;&#125; 每个被代理的方法都对应一个MethodProxy对象，methodProxy.invokeSuper方法最终调用委托类的add方法 123456789public Object invokeSuper(Object obj, Object[] args) throws Throwable &#123; try &#123; init(); FastClassInfo fci = fastClassInfo; return fci.f2.invoke(fci.i2, obj, args); &#125; catch (InvocationTargetException e) &#123; throw e.getTargetException(); &#125;&#125; 单看invokeSuper方法的实现，似乎看不出委托类add方法调用，在MethodProxy实现中，通过FastClassInfo维护了委托类和代理类的FastClass。 123456private static class FastClassInfo &#123; FastClass f1; FastClass f2; int i1; int i2;&#125; 以sayHello方法的methodProxy为例，f1指向委托类对象，f2指向代理类对象，i1和i2分别是方法sayHello和CGLIB$sayHello$0在对象中索引位置。 FastClass实现机制FastClass其实就是对Class对象进行特殊处理，提出下标概念index，通过索引保存方法的引用信息，将原先的反射调用，转化为方法的直接调用，从而体现所谓的fast，下面通过一个例子了解一下FastClass的实现机制。 1、定义原类 123456789class Test &#123; public void f()&#123; System.out.println(\"f method\"); &#125; public void g()&#123; System.out.println(\"g method\"); &#125;&#125; 2、定义Fast类 123456789101112131415161718192021222324class FastTest &#123; public int getIndex(String signature)&#123; switch(signature.hashCode())&#123; case 3078479: return 1; case 3108270: return 2; &#125; return -1; &#125; public Object invoke(int index, Object o, Object[] ol)&#123; Test t = (Test) o; switch(index)&#123; case 1: t.f(); return null; case 2: t.g(); return null; &#125; return null; &#125;&#125; 在FastTest中有两个方法，getIndex中对Test类的每个方法根据hash建立索引，invoke根据指定的索引，直接调用目标方法，避免了反射调用。所以当调用methodProxy.invokeSuper方法时，实际上是调用代理类的CGLIB$sayHello$0方法，CGLIB$sayHello$0直接调用了委托类的sayHello方法","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2018-02-07T16:25:49.000Z","updated":"2018-02-07T16:25:49.000Z","comments":true,"path":"2018/02/08/hello-world/","link":"","permalink":"https://killgc.github.io/shortfeng/2018/02/08/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}