{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"changfeng","url":"https://killgc.github.io/shortfeng"},"pages":[],"posts":[{"title":"拦截器","slug":"拦截器","date":"2018-03-07T09:47:55.000Z","updated":"2018-03-07T09:49:05.000Z","comments":true,"path":"2018/03/07/拦截器/","link":"","permalink":"https://killgc.github.io/shortfeng/2018/03/07/拦截器/","excerpt":"","text":"拦截器标签（空格分隔）： java 拦截器 过滤器 拦截器 过滤器 监听器 ###拦截器与过滤器的区别 过滤器可以简单的理解为“取你所想取”，过滤器关注的是web请求； 拦截器可以简单的理解为“拒你所想拒”，拦截器关注的是方法调用，比如拦截敏感词汇 拦截器是基于java反射机制的，而过滤器是基于函数回调。 拦截器不依赖于Servlet容器，而过滤器依赖于servlet容器。 拦截器只能对action请求起作用，而过滤器可以对几乎所有的请求起作用。 拦截器可以访问action上下文，值栈里的对象，而过滤器不能。在Action的生命周期周，拦截器可以被多次调用，而过滤器只能在容器初始化的时候被调用一次。 执行顺序 ：过滤前 - 拦截前 - Action处理 - 拦截后 - 过滤后过滤器是横向过程 你传入的request,response提前过滤掉一些信息，或者提前设置一些参数，然后再传入servlet或者struts的action进行业务逻辑，比如过滤掉非法url（不是login.do的地址请求，如果用户没有登陆都过滤掉）,或者在传入servlet或者struts的action前统一设置字符集，或者去除掉一些非法字符（聊天室经常用到的，一些骂人的话）。filter 流程是线性的，url传来之后，检查之后 ###拦截器拦截器的原理是基于jdk动态代理，需实现HandlerInterceptor接口或继承HandlerInterceptorAdapter类 1234567891011121314151617181920212223242526272829303132333435363738394041HandlerInterceptor接口：/** * preHandle方法是进行处理器拦截用的，顾名思义，该方法将在Controller处理之前进行调用， * SpringMVC中的Interceptor拦截器是链式的，可以同时存在多个Interceptor， * 然后SpringMVC会根据声明的前后顺序一个接一个的执行， * 而且所有的Interceptor中的preHandle方法都会在Controller方法调用之前调用。 * SpringMVC的这种Interceptor链式结构也是可以进行中断的， * 这种中断方式是令preHandle的返回值为false，当preHandle的返回值为false的时候整个请求就结束了。 */ @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; return true; &#125; /** * 这个方法只会在当前这个Interceptor的preHandle方法返回值为true的时候才会执行。 * postHandle是进行处理器拦截用的，它的执行时间是在处理器进行处理之 后， 也就是在Controller的方法调用之后执行， * 但是它会在DispatcherServlet进行视图的渲染之前执行，也就是说在这个方法中你可以对ModelAndView进行操作。 * 这个方法的链式结构跟正常访问的方向是相反的，也就是说先声明的Interceptor拦截器该方法反而会后调用， * 这跟Struts2里面的拦截器的执行过程有点像， * 只是Struts2里面的intercept方法中要手动的调用ActionInvocation的invoke方法， * Struts2中调用ActionInvocation的invoke方法就是调用下一个Interceptor或者是调用action， * 然后要在Interceptor之前调用的内容都写在调用invoke之前，要在Interceptor之后调用的内容都写在调用invoke方法之后。 */ @Override public void postHandle( HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; &#125; /** * 该方法也是需要当前对应的Interceptor的preHandle方法的返回值为true时才会执行。 * 该方法将在整个请求完成之后，也就是DispatcherServlet渲染了视图执行， 这个方法的主要作用是用于清理资源的， */ @Override public void afterCompletion( HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; &#125; ####配置123456789101112131415&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.1.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd\"&gt; &lt;mvc:interceptors&gt; &lt;!-- 日志拦截器 --&gt; &lt;mvc:interceptor&gt; &lt;mvc:mapping path=\"/**\" /&gt; &lt;mvc:exclude-mapping path=\"/static/**\" /&gt; &lt;bean class=\"拦截器java代码路径\" /&gt; &lt;/mvc:interceptor&gt; &lt;/mvc:interceptors&gt;&lt;/beans&gt;","categories":[],"tags":[]},{"title":"","slug":"动态代理","date":"2018-02-09T03:33:21.000Z","updated":"2018-03-06T16:11:25.000Z","comments":true,"path":"2018/02/09/动态代理/","link":"","permalink":"https://killgc.github.io/shortfeng/2018/02/09/动态代理/","excerpt":"","text":"JAVA动态代理 静态代理 jdk动态代理 cglib动态代理 标签（空格分隔）： jdk动态代理 cglib jdk动态代理 jdk动态代理机制中，有两个重要的类或接口，一个是Proxy，另一个是InvocationHandler Proxy类Proxy类是用来动态创建一个代理对象，经常使用newProxyInstance静态方法12345public static Object newProxyInstance(ClassLoader loader,Class&lt;?&gt;[] interfaces,InvocationHandler h) throws IllegalArgumentException参数：loader 类加载器interfaces 真实类所拥有的所有接口的数组h 调用处理器对象 InvocationHandler接口InvocationHandler接口只有唯一一个invoke方法12345public Object invoke(Object proxy, Method method, Object[] args) throws Throwable;参数：proxy 代理类对象method 调用真实类对象某个方法对应的method对象args 调用真实类对象某个方法传人的参数","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2018-02-07T16:25:49.000Z","updated":"2018-02-07T16:25:49.000Z","comments":true,"path":"2018/02/08/hello-world/","link":"","permalink":"https://killgc.github.io/shortfeng/2018/02/08/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}