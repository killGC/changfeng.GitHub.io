{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"changfeng","url":"https://killgc.github.io/shortfeng"},"pages":[],"posts":[{"title":"ThreadLocal","slug":"ThreadLocal","date":"2018-03-12T09:36:17.000Z","updated":"2018-03-12T10:01:23.000Z","comments":true,"path":"2018/03/12/ThreadLocal/","link":"","permalink":"https://killgc.github.io/shortfeng/2018/03/12/ThreadLocal/","excerpt":"","text":"ThreadLocal Thread类保存了ThreadLocalMap类型的变量, ThreadLocalMap的key为ThreadLoacal对象 1ThreadLocal.ThreadLocalMap threadLocals = null; ThreadLocal类，支持范型 12345678910111213public T get() &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) &#123; ThreadLocalMap.Entry e = map.getEntry(this); if (e != null) &#123; @SuppressWarnings(\"unchecked\") T result = (T)e.value; return result; &#125; &#125; return setInitialValue();&#125; 12345678public void set(T value) &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value);&#125; 123ThreadLocalMap getMap(Thread t) &#123; return t.threadLocals;&#125; 12345678910private T setInitialValue() &#123; T value = initialValue(); Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value); return value;&#125; 示例1234567891011121314151617181920212223242526272829import java.sql.Connection;import java.sql.DriverManager;import java.sql.SQLException;public class ConnectionManager &#123; private static ThreadLocal&lt;Connection&gt; connectionHolder = new ThreadLocal&lt;Connection&gt;() &#123; @Override protected Connection initialValue() &#123; Connection conn = null; try &#123; conn = DriverManager.getConnection( \"jdbc:mysql://localhost:3306/test\", \"username\", \"password\"); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; return conn; &#125; &#125;; public static Connection getConnection() &#123; return connectionHolder.get(); &#125; public static void setConnection(Connection conn) &#123; connectionHolder.set(conn); &#125;&#125;","categories":[],"tags":[]},{"title":"spring aop","slug":"spring aop","date":"2018-03-11T15:08:14.000Z","updated":"2018-03-11T15:24:10.000Z","comments":true,"path":"2018/03/11/spring aop/","link":"","permalink":"https://killgc.github.io/shortfeng/2018/03/11/spring aop/","excerpt":"","text":"spring aop @Transactional 在需要事务管理的地方加@Transactional 注解。@Transactional 注解可以被应用于接口定义和接口方法、类定义和类的 public 方法上。 @Transactional 注解只能应用到 public 可见度的方法上。 如果你在 protected、private 或者 package-visible 的方法上使用 @Transactional 注解，它也不会报错， 但是这个被注解的方法将不会展示已配置的事务设置。 注意仅仅 @Transactional 注解的出现不足于开启事务行为，它仅仅 是一种元数据。必须在配置文件中使用配置元素，才真正开启了事务行为。 通过 元素的 “proxy-target-class” 属性值来控制是基于接口的还是基于类的代理被创建。如果 “proxy-target-class” 属值被设置为 “true”，那么基于类的代理将起作用（这时需要CGLIB库cglib.jar在CLASSPATH中）。如果 “proxy-target-class” 属值被设置为 “false” 或者这个属性被省略，那么标准的JDK基于接口的代理将起作用。 Spring团队建议在具体的类（或类的方法）上使用 @Transactional 注解，而不要使用在类所要实现的任何接口上。在接口上使用 @Transactional 注解，只能当你设置了基于接口的代理时它才生效。因为注解是 不能继承 的，这就意味着如果正在使用基于类的代理时，那么事务的设置将不能被基于类的代理所识别，而且对象也将不会被事务代理所包装。 @Transactional 的事务开启 ，或者是基于接口的 或者是基于类的代理被创建。所以在同一个类中一个方法调用另一个方法有事务的方法，事务是不会起作用的。 1、@Transactional 只能应用到 public 方法才有效 2、避免 Spring 的 AOP 的自调用问题 在 Spring 的 AOP 代理下，只有目标方法由外部调用，目标方法才由 Spring 生成的代理对象来管理，这会造成自调用问题。若同一类中的其他没有@Transactional 注解的方法内部调用有@Transactional 注解的方法，有@Transactional 注解的方法的事务被忽略，不会发生回滚。 123456789101112@Servicepublic class OrderService &#123; private void insert() &#123; insertOrder(); &#125; @Transactional public void insertOrder() &#123; //insert log info //insertOrder //updateAccount &#125;&#125;","categories":[],"tags":[]},{"title":"拦截器","slug":"拦截器","date":"2018-03-07T09:47:55.000Z","updated":"2018-03-08T11:27:38.000Z","comments":true,"path":"2018/03/07/拦截器/","link":"","permalink":"https://killgc.github.io/shortfeng/2018/03/07/拦截器/","excerpt":"","text":"拦截器标签（空格分隔）： java 拦截器 过滤器 拦截器 过滤器 监听器 拦截器与过滤器的区别 过滤器可以简单的理解为“取你所想取”，过滤器关注的是web请求； 拦截器可以简单的理解为“拒你所想拒”，拦截器关注的是方法调用，比如拦截敏感词汇 拦截器是基于java反射机制的，而过滤器是基于函数回调。 拦截器不依赖于Servlet容器，而过滤器依赖于servlet容器。 拦截器只能对action请求起作用，而过滤器可以对几乎所有的请求起作用。 拦截器可以访问action上下文，值栈里的对象，而过滤器不能。在Action的生命周期周，拦截器可以被多次调用，而过滤器只能在容器初始化的时候被调用一次。 执行顺序 ：过滤前 - 拦截前 - Action处理 - 拦截后 - 过滤后过滤器是横向过程 你传入的request,response提前过滤掉一些信息，或者提前设置一些参数，然后再传入servlet或者struts的action进行业务逻辑，比如过滤掉非法url（不是login.do的地址请求，如果用户没有登陆都过滤掉）,或者在传入servlet或者struts的action前统一设置字符集，或者去除掉一些非法字符（聊天室经常用到的，一些骂人的话）。filter 流程是线性的，url传来之后，检查之后 拦截器拦截器的原理是基于jdk动态代理，需实现HandlerInterceptor接口或继承HandlerInterceptorAdapter类 1234567891011121314151617181920212223242526272829303132333435363738394041HandlerInterceptor接口：/*** preHandle方法是进行处理器拦截用的，顾名思义，该方法将在Controller处理之前进行调用，* SpringMVC中的Interceptor拦截器是链式的，可以同时存在多个Interceptor，* 然后SpringMVC会根据声明的前后顺序一个接一个的执行，* 而且所有的Interceptor中的preHandle方法都会在Controller方法调用之前调用。* SpringMVC的这种Interceptor链式结构也是可以进行中断的，* 这种中断方式是令preHandle的返回值为false，当preHandle的返回值为false的时候整个请求就结束了。*/@Overridepublic boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)throws Exception &#123;return true;&#125;/*** 这个方法只会在当前这个Interceptor的preHandle方法返回值为true的时候才会执行。* postHandle是进行处理器拦截用的，它的执行时间是在处理器进行处理之 后， 也就是在Controller的方法调用之后执行，* 但是它会在DispatcherServlet进行视图的渲染之前执行，也就是说在这个方法中你可以对ModelAndView进行操作。* 这个方法的链式结构跟正常访问的方向是相反的，也就是说先声明的Interceptor拦截器该方法反而会后调用，* 这跟Struts2里面的拦截器的执行过程有点像，* 只是Struts2里面的intercept方法中要手动的调用ActionInvocation的invoke方法，* Struts2中调用ActionInvocation的invoke方法就是调用下一个Interceptor或者是调用action，* 然后要在Interceptor之前调用的内容都写在调用invoke之前，要在Interceptor之后调用的内容都写在调用invoke方法之后。*/@Overridepublic void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)throws Exception &#123;&#125;/*** 该方法也是需要当前对应的Interceptor的preHandle方法的返回值为true时才会执行。* 该方法将在整个请求完成之后，也就是DispatcherServlet渲染了视图执行， 这个方法的主要作用是用于清理资源的，*/@Overridepublic void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)throws Exception &#123;&#125; 配置123456789101112131415&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"xmlns:mvc=\"http://www.springframework.org/schema/mvc\"xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.1.xsdhttp://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd\"&gt;&lt;mvc:interceptors&gt;&lt;!-- 日志拦截器 --&gt;&lt;mvc:interceptor&gt;&lt;mvc:mapping path=\"/**\" /&gt;&lt;mvc:exclude-mapping path=\"/static/**\" /&gt;&lt;bean class=\"拦截器java代码路径\" /&gt;&lt;/mvc:interceptor&gt;&lt;/mvc:interceptors&gt;&lt;/beans&gt; 工作流程一个拦截器，只有preHandle方法返回true，postHandle、afterCompletion才有可能被执行；如果preHandle方法返回false，则该拦截器的postHandle、afterCompletion必然不会被执行。 假设我们有两个拦截器，例如叫Interceptor1和Interceptor2，当一个请求过来，正常的流程和中断的流程分别如下。 正常流程注意两个拦截器在执行preHandle方法和执行postHandle、afterCompletion方法时，顺序是颠倒的。 1234567891011121314151. Interceptor1.preHandle2. Interceptor2.preHandle3. Controller处理请求4. Interceptor2.postHandle5. Interceptor1.postHandle6. 渲染视图7. Interceptor2.afterCompletion8. Interceptor1.afterCompletion 中断流程假设执行Interceptor2.preHandle中报错，那么流程被中断，之前被执行过的拦截器的afterCompletion仍然会执行。在本例中，即执行了Interceptor1.afterCompletion。 12345671. Interceptor1.preHandle2. Interceptor2.preHandle//中间流程被中断，不再执行3. Interceptor1.afterCompletion 与过滤器共存时的执行顺序拦截器是在DispatcherServlet这个servlet中执行的，因此所有的请求最先进入Filter，最后离开Filter。其顺序如下。 Filter-&gt;Interceptor.preHandle-&gt;Handler-&gt;Interceptor.postHandle-&gt;Interceptor.afterCompletion-&gt;Filter 应用场景拦截器本质上是面向切面编程（AOP），符合横切关注点的功能都可以放在拦截器中来实现，主要的应用场景包括： 登录验证，判断用户是否登录。权限验证，判断用户是否有权限访问资源。日志记录，记录请求日志，以便统计请求访问量。处理cookie、本地化、国际化、主题等。性能监控，监控请求处理时长等。 spring boot配置拦截器为了使自定义的拦截器生效，需要注册拦截器到spring容器中，具体的做法是继承WebMvcConfigurerAdapter类，覆盖其addInterceptors(InterceptorRegistry registry)方法。最后别忘了把Bean注册到Spring容器中，可以选择@Component 或者 @Configuration 123456789101112131415@Componentpublic class InterceptorConfiguration extends WebMvcConfigurerAdapter&#123;@Overridepublic void addInterceptors(InterceptorRegistry registry) &#123;// 注册拦截器InterceptorRegistration ir = registry.addInterceptor(new LoginInterceptor());// 配置拦截的路径ir.addPathPatterns(&quot;/**&quot;);// 配置不拦截的路径ir.excludePathPatterns(&quot;/**.html&quot;);// 还可以在这里注册其它的拦截器//registry.addInterceptor(new OtherInterceptor()).addPathPatterns(&quot;/**&quot;);&#125;&#125;","categories":[],"tags":[]},{"title":"JAVA动态代理","slug":"动态代理","date":"2018-02-09T09:47:55.000Z","updated":"2018-03-11T13:55:41.000Z","comments":true,"path":"2018/02/09/动态代理/","link":"","permalink":"https://killgc.github.io/shortfeng/2018/02/09/动态代理/","excerpt":"","text":"JAVA动态代理 静态代理的代理关系在编译时就确定了，而动态代理的代理关系是在编译期确定的。静态代理实现简单，适合于代理类较少且确定的情况，而动态代理则给我们提供了更大的灵活性 JDK原生动态代理是Java原生支持的，不需要任何外部依赖，但是它只能基于接口进行代理；CGLIB通过继承的方式进行代理，无论目标对象有没有实现接口都可以代理，但是无法处理final、private方法 CGLib创建的动态代理对象性能比JDK创建的动态代理对象的性能高不少，但是CGLib在创建代理对象时所花费的时间却比JDK多得多，所以对于单例的对象，因为无需频繁创建对象，用CGLib合适，反之，使用JDK方式要更为合适一些 jdk采用反射机制调用委托类的方法，cglib采用类似索引的方式直接调用委托类方法 标签（空格分隔）： jdk动态代理 cglib jdk动态代理 jdk动态代理机制中，有两个重要的类或接口，一个是Proxy，另一个是InvocationHandler Proxy类Proxy类是用来动态创建一个代理对象，经常使用newProxyInstance静态方法12345public static Object newProxyInstance(ClassLoader loader,Class&lt;?&gt;[] interfaces,InvocationHandler h) throws IllegalArgumentException参数：loader 类加载器interfaces 真实类所拥有的所有接口的数组h 调用处理器对象 InvocationHandler接口InvocationHandler接口只有唯一一个invoke方法12345public Object invoke(Object proxy, Method method, Object[] args) throws Throwable;参数：proxy 代理类对象method 调用真实类对象某个方法对应的method对象args 调用真实类对象某个方法传人的参数 示例1、主题接口 123456package com.example.ford.proxy;public interface Subject &#123; String sayHello(String name); String sayGoodBye();&#125; 2、 被代理类 12345678910111213package com.example.ford.proxy;public class RealSubject implements Subject&#123; @Override public String sayHello(String name) &#123; return \"hello \"+name; &#125; @Override public String sayGoodBye() &#123; return \" good bye\"; &#125;&#125; 3、调用处理器 123456789101112131415161718192021package com.example.ford.proxy;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;public class TestInvocationHandler implements InvocationHandler&#123; private Subject subject; public TestInvocationHandler(Subject subject)&#123; this.subject = subject; &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; System.out.println(proxy.getClass()); System.out.println(\"开始执行 \"+method.getName()); Object returnValue = method.invoke(subject,args); System.out.println(\"结束执行 \"+method.getName()); return returnValue; &#125;&#125; 3、测试 12345678910111213141516171819package com.example.ford.proxy;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Proxy;public class TestMain &#123; public static void main(String[] args) &#123; Subject subject = new RealSubject(); InvocationHandler handler = new TestInvocationHandler(subject); Class cls = subject.getClass(); ClassLoader loader = cls.getClassLoader(); Class[] interfaces = cls.getInterfaces(); Subject proxy = (Subject) Proxy.newProxyInstance(loader, interfaces, handler); String returnValue1 = proxy.sayHello(\"changfeng\"); System.out.println(returnValue1); String returnValue2 = proxy.sayGoodBye(); System.out.println(returnValue2); &#125;&#125; 测试结果 12345678class com.sun.proxy.$Proxy0开始执行 sayHello结束执行 sayHellohello changfengclass com.sun.proxy.$Proxy0开始执行 sayGoodBye结束执行 sayGoodBye good bye 原理分析生成代理类类文件： 1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.example.ford.proxy;import sun.misc.ProxyGenerator;import java.io.File;import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.IOException;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Proxy;public class JDKProxyTest &#123; public static void main(String[] args)&#123; Subject subject = new RealSubject(); InvocationHandler handler = new TestInvocationHandler(subject); Class cls = subject.getClass(); ClassLoader loader = cls.getClassLoader(); Class[] interfaces = cls.getInterfaces(); Subject proxy = (Subject) Proxy.newProxyInstance(loader, interfaces, handler); createProxyClassFile(); &#125; private static void createProxyClassFile()&#123; String name = \"ProxySubject\"; byte[] data = ProxyGenerator.generateProxyClass(name,new Class[]&#123;Subject.class&#125;); FileOutputStream out =null; try &#123; out = new FileOutputStream(name+\".class\"); System.out.println((new File(\"hello\")).getAbsolutePath()); out.write(data); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;finally &#123; if(null!=out) try &#123; out.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 利用jd-gui反编译代理类class文件，可以发现最终生成的代理类继承Proxy类、实现Subject接口,代理类实现了Subject接口的sayHello方法、sayGoodBye方法,在实现Subject接口方法的内部，通过反射调用了InvocationHandlerImpl的invoke方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122import com.example.ford.proxy.Subject;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;import java.lang.reflect.UndeclaredThrowableException;public final class ProxySubject extends Proxy implements Subject&#123; private static Method m1; private static Method m3; private static Method m2; private static Method m4; private static Method m0; public ProxySubject(InvocationHandler paramInvocationHandler) &#123; super(paramInvocationHandler); &#125; public final boolean equals(Object paramObject) &#123; try &#123; return ((Boolean)this.h.invoke(this, m1, new Object[] &#123; paramObject &#125;)).booleanValue(); &#125; catch (Error|RuntimeException localError) &#123; throw localError; &#125; catch (Throwable localThrowable) &#123; throw new UndeclaredThrowableException(localThrowable); &#125; &#125; public final String sayHello(String paramString) &#123; try &#123; return (String)this.h.invoke(this, m3, new Object[] &#123; paramString &#125;); &#125; catch (Error|RuntimeException localError) &#123; throw localError; &#125; catch (Throwable localThrowable) &#123; throw new UndeclaredThrowableException(localThrowable); &#125; &#125; public final String toString() &#123; try &#123; return (String)this.h.invoke(this, m2, null); &#125; catch (Error|RuntimeException localError) &#123; throw localError; &#125; catch (Throwable localThrowable) &#123; throw new UndeclaredThrowableException(localThrowable); &#125; &#125; public final String sayGoodBye() &#123; try &#123; return (String)this.h.invoke(this, m4, null); &#125; catch (Error|RuntimeException localError) &#123; throw localError; &#125; catch (Throwable localThrowable) &#123; throw new UndeclaredThrowableException(localThrowable); &#125; &#125; public final int hashCode() &#123; try &#123; return ((Integer)this.h.invoke(this, m0, null)).intValue(); &#125; catch (Error|RuntimeException localError) &#123; throw localError; &#125; catch (Throwable localThrowable) &#123; throw new UndeclaredThrowableException(localThrowable); &#125; &#125; static &#123; try &#123; m1 = Class.forName(\"java.lang.Object\").getMethod(\"equals\", new Class[] &#123; Class.forName(\"java.lang.Object\") &#125;); m3 = Class.forName(\"com.example.ford.proxy.Subject\").getMethod(\"sayHello\", new Class[] &#123; Class.forName(\"java.lang.String\") &#125;); m2 = Class.forName(\"java.lang.Object\").getMethod(\"toString\", new Class[0]); m4 = Class.forName(\"com.example.ford.proxy.Subject\").getMethod(\"sayGoodBye\", new Class[0]); m0 = Class.forName(\"java.lang.Object\").getMethod(\"hashCode\", new Class[0]); return; &#125; catch (NoSuchMethodException localNoSuchMethodException) &#123; throw new NoSuchMethodError(localNoSuchMethodException.getMessage()); &#125; catch (ClassNotFoundException localClassNotFoundException) &#123; throw new NoClassDefFoundError(localClassNotFoundException.getMessage()); &#125; &#125;&#125; 注意:对于从Object中继承的方法，JDK Proxy会把hashCode()、equals()、toString()这三个非接口方法转发给InvocationHandler，其余的Object方法则不会转发 cglib动态代理 cglib动态代理必须实现MethodInterceptor接口 MethodInterceptor接口1234567891011package org.springframework.cglib.proxy;import java.lang.reflect.Method;public interface MethodInterceptor extends Callback &#123; Object intercept(Object var1, Method var2, Object[] var3, MethodProxy var4) throws Throwable; 参数1 代理对象 参数2 方法对象 参数3 方法参数 参数4 方法对应的&#125; 示例12345678910111213141516171819202122232425262728293031323334353637package com.example.ford.proxy;import org.springframework.cglib.proxy.Enhancer;import org.springframework.cglib.proxy.MethodInterceptor;import org.springframework.cglib.proxy.MethodProxy;import java.lang.reflect.Method;public class CglibProxy implements MethodInterceptor&#123; private Enhancer enhancer = new Enhancer(); public Object getProxy(Class cls)&#123; enhancer.setSuperclass(cls); enhancer.setCallback(this); return enhancer.create(); &#125; @Override public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable &#123; System.out.println(o.getClass()); System.out.println(\"开始执行 \"+method.getName()); //我们一般使用proxy.invokeSuper(obj,args)方法。这个很好理解，就是执行原始类的方法。还有一个方法proxy.invoke(obj,args)，这是执行生成子类的方法。 //如果传入的obj就是子类的话，会发生内存溢出，因为子类的方法不停地进入intercept方法，而这个方法又去调用子类的方法，两个方法直接循环调用了。 Object returnValue = methodProxy.invokeSuper(o,objects); //Object returnValue = methodProxy.invoke(o,objects); System.out.println(\"结束执行 \"+method.getName()); return returnValue; &#125; public static void main(String[] args)&#123; CglibProxy cglibProxy = new CglibProxy(); RealSubject realSubject = (RealSubject)cglibProxy.getProxy(RealSubject.class); Object returnValue1 = realSubject.sayHello(\"changfeng\"); System.out.println(returnValue1); Object returnValue2 = realSubject.sayGoodBye(); System.out.println(returnValue2); &#125;&#125; 注意：对于从Object中继承的方法，CGLIB代理也会进行代理，如hashCode()、equals()、toString()等，但是getClass()、wait()等方法不会，因为它是final方法，CGLIB无法代理 注意：既然是继承就不得不考虑final的问题。我们知道final类型不能有子类，所以CGLIB不能代理final类型，遇到这种情况会抛出类似如下异常： java.lang.IllegalArgumentException: Cannot subclass final class cglib.HelloConcrete 注意：同样的，final方法是不能重载的，所以也不能通过CGLIB代理，遇到这种情况不会抛异常，而是会跳过final方法只代理其他方法。 源码分析通过以下方式可以生成代理类class文件System.setProperty(DebuggingClassWriter.DEBUG_LOCATION_PROPERTY, “C:\\\\Code\\\\whywhy\\\\target\\\\classes\\\\zzzzzz”) 用jd-gui反编译代理类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460package com.example.ford.proxy;import java.lang.reflect.Method;import org.springframework.cglib.proxy.Callback;import org.springframework.cglib.proxy.Factory;import org.springframework.cglib.proxy.MethodInterceptor;import org.springframework.cglib.proxy.MethodProxy;public class RealSubject$$EnhancerByCGLIB$$6a387257 extends RealSubject implements Factory&#123; private boolean CGLIB$BOUND; public static Object CGLIB$FACTORY_DATA; private static final ThreadLocal CGLIB$THREAD_CALLBACKS; private static final Callback[] CGLIB$STATIC_CALLBACKS; private MethodInterceptor CGLIB$CALLBACK_0; private static Object CGLIB$CALLBACK_FILTER; private static final Method CGLIB$sayHello$0$Method; private static final MethodProxy CGLIB$sayHello$0$Proxy; private static final Object[] CGLIB$emptyArgs; private static final Method CGLIB$sayGoodBye$1$Method; private static final MethodProxy CGLIB$sayGoodBye$1$Proxy; private static final Method CGLIB$equals$2$Method; private static final MethodProxy CGLIB$equals$2$Proxy; private static final Method CGLIB$toString$3$Method; private static final MethodProxy CGLIB$toString$3$Proxy; private static final Method CGLIB$hashCode$4$Method; private static final MethodProxy CGLIB$hashCode$4$Proxy; private static final Method CGLIB$clone$5$Method; private static final MethodProxy CGLIB$clone$5$Proxy; /* Error */ static void CGLIB$STATICHOOK1() &#123; // Byte code: // 0: new 22 java/lang/ThreadLocal // 3: dup // 4: invokespecial 25 java/lang/ThreadLocal:&lt;init&gt; ()V // 7: putstatic 27 com/example/ford/proxy/RealSubject$$EnhancerByCGLIB$$6a387257:CGLIB$THREAD_CALLBACKS Ljava/lang/ThreadLocal; // 10: iconst_0 // 11: anewarray 48 java/lang/Object // 14: putstatic 69 com/example/ford/proxy/RealSubject$$EnhancerByCGLIB$$6a387257:CGLIB$emptyArgs [Ljava/lang/Object; // 17: ldc -108 // 19: invokestatic 154 java/lang/Class:forName (Ljava/lang/String;)Ljava/lang/Class; // 22: astore_0 // 23: iconst_4 // 24: anewarray 58 java/lang/String // 27: dup // 28: iconst_0 // 29: ldc -101 // 31: aastore // 32: dup // 33: iconst_1 // 34: ldc -100 // 36: aastore // 37: dup // 38: iconst_2 // 39: ldc -99 // 41: aastore // 42: dup // 43: iconst_3 // 44: ldc -98 // 46: aastore // 47: ldc -96 // 49: invokestatic 154 java/lang/Class:forName (Ljava/lang/String;)Ljava/lang/Class; // 52: dup // 53: astore_1 // 54: invokevirtual 164 java/lang/Class:getDeclaredMethods ()[Ljava/lang/reflect/Method; // 57: invokestatic 170 org/springframework/cglib/core/ReflectUtils:findMethods ([Ljava/lang/String;[Ljava/lang/reflect/Method;)[Ljava/lang/reflect/Method; // 60: dup // 61: iconst_0 // 62: aaload // 63: putstatic 46 com/example/ford/proxy/RealSubject$$EnhancerByCGLIB$$6a387257:CGLIB$sayHello$0$Method Ljava/lang/reflect/Method; // 66: aload_1 // 67: aload_0 // 68: ldc -100 // 70: ldc -101 // 72: ldc -85 // 74: invokestatic 177 org/springframework/cglib/proxy/MethodProxy:create (Ljava/lang/Class;Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)Lorg/springframework/cglib/proxy/MethodProxy; // 77: putstatic 50 com/example/ford/proxy/RealSubject$$EnhancerByCGLIB$$6a387257:CGLIB$sayHello$0$Proxy Lorg/springframework/cglib/proxy/MethodProxy; // 80: dup // 81: iconst_1 // 82: aaload // 83: putstatic 67 com/example/ford/proxy/RealSubject$$EnhancerByCGLIB$$6a387257:CGLIB$sayGoodBye$1$Method Ljava/lang/reflect/Method; // 86: aload_1 // 87: aload_0 // 88: ldc -98 // 90: ldc -99 // 92: ldc -78 // 94: invokestatic 177 org/springframework/cglib/proxy/MethodProxy:create (Ljava/lang/Class;Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)Lorg/springframework/cglib/proxy/MethodProxy; // 97: putstatic 71 com/example/ford/proxy/RealSubject$$EnhancerByCGLIB$$6a387257:CGLIB$sayGoodBye$1$Proxy Lorg/springframework/cglib/proxy/MethodProxy; // 100: pop // 101: bipush 8 // 103: anewarray 58 java/lang/String // 106: dup // 107: iconst_0 // 108: ldc -77 // 110: aastore // 111: dup // 112: iconst_1 // 113: ldc -76 // 115: aastore // 116: dup // 117: iconst_2 // 118: ldc -75 // 120: aastore // 121: dup // 122: iconst_3 // 123: ldc -98 // 125: aastore // 126: dup // 127: iconst_4 // 128: ldc -74 // 130: aastore // 131: dup // 132: iconst_5 // 133: ldc -73 // 135: aastore // 136: dup // 137: bipush 6 // 139: ldc -72 // 141: aastore // 142: dup // 143: bipush 7 // 145: ldc -71 // 147: aastore // 148: ldc -69 // 150: invokestatic 154 java/lang/Class:forName (Ljava/lang/String;)Ljava/lang/Class; // 153: dup // 154: astore_1 // 155: invokevirtual 164 java/lang/Class:getDeclaredMethods ()[Ljava/lang/reflect/Method; // 158: invokestatic 170 org/springframework/cglib/core/ReflectUtils:findMethods ([Ljava/lang/String;[Ljava/lang/reflect/Method;)[Ljava/lang/reflect/Method; // 161: dup // 162: iconst_0 // 163: aaload // 164: putstatic 80 com/example/ford/proxy/RealSubject$$EnhancerByCGLIB$$6a387257:CGLIB$equals$2$Method Ljava/lang/reflect/Method; // 167: aload_1 // 168: aload_0 // 169: ldc -76 // 171: ldc -77 // 173: ldc -68 // 175: invokestatic 177 org/springframework/cglib/proxy/MethodProxy:create (Ljava/lang/Class;Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)Lorg/springframework/cglib/proxy/MethodProxy; // 178: putstatic 82 com/example/ford/proxy/RealSubject$$EnhancerByCGLIB$$6a387257:CGLIB$equals$2$Proxy Lorg/springframework/cglib/proxy/MethodProxy; // 181: dup // 182: iconst_1 // 183: aaload // 184: putstatic 96 com/example/ford/proxy/RealSubject$$EnhancerByCGLIB$$6a387257:CGLIB$toString$3$Method Ljava/lang/reflect/Method; // 187: aload_1 // 188: aload_0 // 189: ldc -98 // 191: ldc -75 // 193: ldc -67 // 195: invokestatic 177 org/springframework/cglib/proxy/MethodProxy:create (Ljava/lang/Class;Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)Lorg/springframework/cglib/proxy/MethodProxy; // 198: putstatic 98 com/example/ford/proxy/RealSubject$$EnhancerByCGLIB$$6a387257:CGLIB$toString$3$Proxy Lorg/springframework/cglib/proxy/MethodProxy; // 201: dup // 202: iconst_2 // 203: aaload // 204: putstatic 107 com/example/ford/proxy/RealSubject$$EnhancerByCGLIB$$6a387257:CGLIB$hashCode$4$Method Ljava/lang/reflect/Method; // 207: aload_1 // 208: aload_0 // 209: ldc -73 // 211: ldc -74 // 213: ldc -66 // 215: invokestatic 177 org/springframework/cglib/proxy/MethodProxy:create (Ljava/lang/Class;Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)Lorg/springframework/cglib/proxy/MethodProxy; // 218: putstatic 109 com/example/ford/proxy/RealSubject$$EnhancerByCGLIB$$6a387257:CGLIB$hashCode$4$Proxy Lorg/springframework/cglib/proxy/MethodProxy; // 221: dup // 222: iconst_3 // 223: aaload // 224: putstatic 125 com/example/ford/proxy/RealSubject$$EnhancerByCGLIB$$6a387257:CGLIB$clone$5$Method Ljava/lang/reflect/Method; // 227: aload_1 // 228: aload_0 // 229: ldc -71 // 231: ldc -72 // 233: ldc -65 // 235: invokestatic 177 org/springframework/cglib/proxy/MethodProxy:create (Ljava/lang/Class;Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)Lorg/springframework/cglib/proxy/MethodProxy; // 238: putstatic 127 com/example/ford/proxy/RealSubject$$EnhancerByCGLIB$$6a387257:CGLIB$clone$5$Proxy Lorg/springframework/cglib/proxy/MethodProxy; // 241: pop // 242: return // 243: athrow &#125; final String CGLIB$sayHello$0(String paramString) &#123; return super.sayHello(paramString); &#125; public final String sayHello(String paramString) &#123; MethodInterceptor tmp4_1 = this.CGLIB$CALLBACK_0; if (tmp4_1 == null) &#123; tmp4_1; CGLIB$BIND_CALLBACKS(this); &#125; MethodInterceptor tmp17_14 = this.CGLIB$CALLBACK_0; if (tmp17_14 != null) &#123; return (String)tmp17_14.intercept(this, CGLIB$sayHello$0$Method, new Object[] &#123; paramString &#125;, CGLIB$sayHello$0$Proxy); &#125; return super.sayHello(paramString); &#125; final String CGLIB$sayGoodBye$1() &#123; return super.sayGoodBye(); &#125; public final String sayGoodBye() &#123; MethodInterceptor tmp4_1 = this.CGLIB$CALLBACK_0; if (tmp4_1 == null) &#123; tmp4_1; CGLIB$BIND_CALLBACKS(this); &#125; MethodInterceptor tmp17_14 = this.CGLIB$CALLBACK_0; if (tmp17_14 != null) &#123; return (String)tmp17_14.intercept(this, CGLIB$sayGoodBye$1$Method, CGLIB$emptyArgs, CGLIB$sayGoodBye$1$Proxy); &#125; return super.sayGoodBye(); &#125; final boolean CGLIB$equals$2(Object paramObject) &#123; return super.equals(paramObject); &#125; public final boolean equals(Object paramObject) &#123; MethodInterceptor tmp4_1 = this.CGLIB$CALLBACK_0; if (tmp4_1 == null) &#123; tmp4_1; CGLIB$BIND_CALLBACKS(this); &#125; MethodInterceptor tmp17_14 = this.CGLIB$CALLBACK_0; if (tmp17_14 != null) &#123; Object tmp41_36 = tmp17_14.intercept(this, CGLIB$equals$2$Method, new Object[] &#123; paramObject &#125;, CGLIB$equals$2$Proxy); tmp41_36; return tmp41_36 == null ? false : ((Boolean)tmp41_36).booleanValue(); &#125; return super.equals(paramObject); &#125; final String CGLIB$toString$3() &#123; return super.toString(); &#125; public final String toString() &#123; MethodInterceptor tmp4_1 = this.CGLIB$CALLBACK_0; if (tmp4_1 == null) &#123; tmp4_1; CGLIB$BIND_CALLBACKS(this); &#125; MethodInterceptor tmp17_14 = this.CGLIB$CALLBACK_0; if (tmp17_14 != null) &#123; return (String)tmp17_14.intercept(this, CGLIB$toString$3$Method, CGLIB$emptyArgs, CGLIB$toString$3$Proxy); &#125; return super.toString(); &#125; final int CGLIB$hashCode$4() &#123; return super.hashCode(); &#125; public final int hashCode() &#123; MethodInterceptor tmp4_1 = this.CGLIB$CALLBACK_0; if (tmp4_1 == null) &#123; tmp4_1; CGLIB$BIND_CALLBACKS(this); &#125; MethodInterceptor tmp17_14 = this.CGLIB$CALLBACK_0; if (tmp17_14 != null) &#123; Object tmp36_31 = tmp17_14.intercept(this, CGLIB$hashCode$4$Method, CGLIB$emptyArgs, CGLIB$hashCode$4$Proxy); tmp36_31; return tmp36_31 == null ? 0 : ((Number)tmp36_31).intValue(); &#125; return super.hashCode(); &#125; final Object CGLIB$clone$5() throws CloneNotSupportedException &#123; return super.clone(); &#125; protected final Object clone() throws CloneNotSupportedException &#123; MethodInterceptor tmp4_1 = this.CGLIB$CALLBACK_0; if (tmp4_1 == null) &#123; tmp4_1; CGLIB$BIND_CALLBACKS(this); &#125; MethodInterceptor tmp17_14 = this.CGLIB$CALLBACK_0; if (tmp17_14 != null) &#123; return tmp17_14.intercept(this, CGLIB$clone$5$Method, CGLIB$emptyArgs, CGLIB$clone$5$Proxy); &#125; return super.clone(); &#125; /* Error */ public static MethodProxy CGLIB$findMethodProxy(org.springframework.cglib.core.Signature arg0) &#123; // Byte code: // 0: aload_0 // 1: invokevirtual 130 java/lang/Object:toString ()Ljava/lang/String; // 4: dup // 5: invokevirtual 131 java/lang/Object:hashCode ()I // 8: lookupswitch default:+132-&gt;140, -1816210712:+60-&gt;68, -508378822:+72-&gt;80, 1577955665:+84-&gt;92, 1826985398:+96-&gt;104, 1913648695:+108-&gt;116, 1984935277:+120-&gt;128 // 68: ldc -123 // 70: invokevirtual 134 java/lang/Object:equals (Ljava/lang/Object;)Z // 73: ifeq +68 -&gt; 141 // 76: getstatic 50 com/example/ford/proxy/RealSubject$$EnhancerByCGLIB$$6a387257:CGLIB$sayHello$0$Proxy Lorg/springframework/cglib/proxy/MethodProxy; // 79: areturn // 80: ldc -120 // 82: invokevirtual 134 java/lang/Object:equals (Ljava/lang/Object;)Z // 85: ifeq +56 -&gt; 141 // 88: getstatic 127 com/example/ford/proxy/RealSubject$$EnhancerByCGLIB$$6a387257:CGLIB$clone$5$Proxy Lorg/springframework/cglib/proxy/MethodProxy; // 91: areturn // 92: ldc -118 // 94: invokevirtual 134 java/lang/Object:equals (Ljava/lang/Object;)Z // 97: ifeq +44 -&gt; 141 // 100: getstatic 71 com/example/ford/proxy/RealSubject$$EnhancerByCGLIB$$6a387257:CGLIB$sayGoodBye$1$Proxy Lorg/springframework/cglib/proxy/MethodProxy; // 103: areturn // 104: ldc -116 // 106: invokevirtual 134 java/lang/Object:equals (Ljava/lang/Object;)Z // 109: ifeq +32 -&gt; 141 // 112: getstatic 82 com/example/ford/proxy/RealSubject$$EnhancerByCGLIB$$6a387257:CGLIB$equals$2$Proxy Lorg/springframework/cglib/proxy/MethodProxy; // 115: areturn // 116: ldc -114 // 118: invokevirtual 134 java/lang/Object:equals (Ljava/lang/Object;)Z // 121: ifeq +20 -&gt; 141 // 124: getstatic 98 com/example/ford/proxy/RealSubject$$EnhancerByCGLIB$$6a387257:CGLIB$toString$3$Proxy Lorg/springframework/cglib/proxy/MethodProxy; // 127: areturn // 128: ldc -112 // 130: invokevirtual 134 java/lang/Object:equals (Ljava/lang/Object;)Z // 133: ifeq +8 -&gt; 141 // 136: getstatic 109 com/example/ford/proxy/RealSubject$$EnhancerByCGLIB$$6a387257:CGLIB$hashCode$4$Proxy Lorg/springframework/cglib/proxy/MethodProxy; // 139: areturn // 140: pop // 141: aconst_null // 142: areturn &#125; public RealSubject$$EnhancerByCGLIB$$6a387257() &#123; CGLIB$BIND_CALLBACKS(this); &#125; public static void CGLIB$SET_THREAD_CALLBACKS(Callback[] paramArrayOfCallback) &#123; CGLIB$THREAD_CALLBACKS.set(paramArrayOfCallback); &#125; public static void CGLIB$SET_STATIC_CALLBACKS(Callback[] paramArrayOfCallback) &#123; CGLIB$STATIC_CALLBACKS = paramArrayOfCallback; &#125; private static final void CGLIB$BIND_CALLBACKS(Object paramObject) &#123; 6a387257 local6a387257 = (6a387257)paramObject; if (!local6a387257.CGLIB$BOUND) &#123; local6a387257.CGLIB$BOUND = true; Object tmp23_20 = CGLIB$THREAD_CALLBACKS.get(); if (tmp23_20 == null) &#123; tmp23_20; CGLIB$STATIC_CALLBACKS; &#125; local6a387257.CGLIB$CALLBACK_0 = (tmp31_28 == null ? tmp31_28 : (MethodInterceptor)((Callback[])tmp23_20)[0]); &#125; &#125; public Object newInstance(Callback[] paramArrayOfCallback) &#123; CGLIB$SET_THREAD_CALLBACKS(paramArrayOfCallback); CGLIB$SET_THREAD_CALLBACKS(null); return new 6a387257(); &#125; public Object newInstance(Callback paramCallback) &#123; CGLIB$SET_THREAD_CALLBACKS(new Callback[] &#123; paramCallback &#125;); CGLIB$SET_THREAD_CALLBACKS(null); return new 6a387257(); &#125; /* Error */ public Object newInstance(Class[] arg1, Object[] arg2, Callback[] arg3) &#123; // Byte code: // 0: aload_3 // 1: invokestatic 210 com/example/ford/proxy/RealSubject$$EnhancerByCGLIB$$6a387257:CGLIB$SET_THREAD_CALLBACKS ([Lorg/springframework/cglib/proxy/Callback;)V // 4: new 2 com/example/ford/proxy/RealSubject$$EnhancerByCGLIB$$6a387257 // 7: dup // 8: aload_1 // 9: dup // 10: arraylength // 11: tableswitch default:+24-&gt;35, 0:+17-&gt;28 // 28: pop // 29: invokespecial 211 com/example/ford/proxy/RealSubject$$EnhancerByCGLIB$$6a387257:&lt;init&gt; ()V // 32: goto +17 -&gt; 49 // 35: goto +3 -&gt; 38 // 38: pop // 39: new 217 java/lang/IllegalArgumentException // 42: dup // 43: ldc -37 // 45: invokespecial 222 java/lang/IllegalArgumentException:&lt;init&gt; (Ljava/lang/String;)V // 48: athrow // 49: aconst_null // 50: invokestatic 210 com/example/ford/proxy/RealSubject$$EnhancerByCGLIB$$6a387257:CGLIB$SET_THREAD_CALLBACKS ([Lorg/springframework/cglib/proxy/Callback;)V // 53: areturn &#125; public Callback getCallback(int paramInt) &#123; CGLIB$BIND_CALLBACKS(this); switch (paramInt) &#123; case 0: break; &#125; return null; &#125; public void setCallback(int paramInt, Callback paramCallback) &#123; switch (paramInt) &#123; case 0: this.CGLIB$CALLBACK_0 = ((MethodInterceptor)paramCallback); break; &#125; &#125; public Callback[] getCallbacks() &#123; CGLIB$BIND_CALLBACKS(this); return new Callback[] &#123; this.CGLIB$CALLBACK_0 &#125;; &#125; public void setCallbacks(Callback[] paramArrayOfCallback) &#123; this.CGLIB$CALLBACK_0 = ((MethodInterceptor)paramArrayOfCallback[0]); &#125; static &#123;&#125;&#125; 每个被代理的方法都对应一个MethodProxy对象，methodProxy.invokeSuper方法最终调用委托类的add方法 123456789public Object invokeSuper(Object obj, Object[] args) throws Throwable &#123; try &#123; init(); FastClassInfo fci = fastClassInfo; return fci.f2.invoke(fci.i2, obj, args); &#125; catch (InvocationTargetException e) &#123; throw e.getTargetException(); &#125;&#125; 单看invokeSuper方法的实现，似乎看不出委托类add方法调用，在MethodProxy实现中，通过FastClassInfo维护了委托类和代理类的FastClass。 123456private static class FastClassInfo &#123; FastClass f1; FastClass f2; int i1; int i2;&#125; 以sayHello方法的methodProxy为例，f1指向委托类对象，f2指向代理类对象，i1和i2分别是方法sayHello和CGLIB$sayHello$0在对象中索引位置。 FastClass实现机制FastClass其实就是对Class对象进行特殊处理，提出下标概念index，通过索引保存方法的引用信息，将原先的反射调用，转化为方法的直接调用，从而体现所谓的fast，下面通过一个例子了解一下FastClass的实现机制。 1、定义原类 123456789class Test &#123; public void f()&#123; System.out.println(\"f method\"); &#125; public void g()&#123; System.out.println(\"g method\"); &#125;&#125; 2、定义Fast类 123456789101112131415161718192021222324class FastTest &#123; public int getIndex(String signature)&#123; switch(signature.hashCode())&#123; case 3078479: return 1; case 3108270: return 2; &#125; return -1; &#125; public Object invoke(int index, Object o, Object[] ol)&#123; Test t = (Test) o; switch(index)&#123; case 1: t.f(); return null; case 2: t.g(); return null; &#125; return null; &#125;&#125; 在FastTest中有两个方法，getIndex中对Test类的每个方法根据hash建立索引，invoke根据指定的索引，直接调用目标方法，避免了反射调用。所以当调用methodProxy.invokeSuper方法时，实际上是调用代理类的CGLIB$sayHello$0方法，CGLIB$sayHello$0直接调用了委托类的sayHello方法","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2018-02-07T16:25:49.000Z","updated":"2018-02-07T16:25:49.000Z","comments":true,"path":"2018/02/08/hello-world/","link":"","permalink":"https://killgc.github.io/shortfeng/2018/02/08/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}