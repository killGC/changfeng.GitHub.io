{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"changfeng","url":"https://killgc.github.io/shortfeng"},"pages":[],"posts":[{"title":"拦截器","slug":"拦截器","date":"2018-03-07T09:47:55.000Z","updated":"2018-03-08T11:27:38.000Z","comments":true,"path":"2018/03/07/拦截器/","link":"","permalink":"https://killgc.github.io/shortfeng/2018/03/07/拦截器/","excerpt":"","text":"拦截器标签（空格分隔）： java 拦截器 过滤器 拦截器 过滤器 监听器 拦截器与过滤器的区别 过滤器可以简单的理解为“取你所想取”，过滤器关注的是web请求； 拦截器可以简单的理解为“拒你所想拒”，拦截器关注的是方法调用，比如拦截敏感词汇 拦截器是基于java反射机制的，而过滤器是基于函数回调。 拦截器不依赖于Servlet容器，而过滤器依赖于servlet容器。 拦截器只能对action请求起作用，而过滤器可以对几乎所有的请求起作用。 拦截器可以访问action上下文，值栈里的对象，而过滤器不能。在Action的生命周期周，拦截器可以被多次调用，而过滤器只能在容器初始化的时候被调用一次。 执行顺序 ：过滤前 - 拦截前 - Action处理 - 拦截后 - 过滤后过滤器是横向过程 你传入的request,response提前过滤掉一些信息，或者提前设置一些参数，然后再传入servlet或者struts的action进行业务逻辑，比如过滤掉非法url（不是login.do的地址请求，如果用户没有登陆都过滤掉）,或者在传入servlet或者struts的action前统一设置字符集，或者去除掉一些非法字符（聊天室经常用到的，一些骂人的话）。filter 流程是线性的，url传来之后，检查之后 拦截器拦截器的原理是基于jdk动态代理，需实现HandlerInterceptor接口或继承HandlerInterceptorAdapter类 1234567891011121314151617181920212223242526272829303132333435363738394041HandlerInterceptor接口：/*** preHandle方法是进行处理器拦截用的，顾名思义，该方法将在Controller处理之前进行调用，* SpringMVC中的Interceptor拦截器是链式的，可以同时存在多个Interceptor，* 然后SpringMVC会根据声明的前后顺序一个接一个的执行，* 而且所有的Interceptor中的preHandle方法都会在Controller方法调用之前调用。* SpringMVC的这种Interceptor链式结构也是可以进行中断的，* 这种中断方式是令preHandle的返回值为false，当preHandle的返回值为false的时候整个请求就结束了。*/@Overridepublic boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)throws Exception &#123;return true;&#125;/*** 这个方法只会在当前这个Interceptor的preHandle方法返回值为true的时候才会执行。* postHandle是进行处理器拦截用的，它的执行时间是在处理器进行处理之 后， 也就是在Controller的方法调用之后执行，* 但是它会在DispatcherServlet进行视图的渲染之前执行，也就是说在这个方法中你可以对ModelAndView进行操作。* 这个方法的链式结构跟正常访问的方向是相反的，也就是说先声明的Interceptor拦截器该方法反而会后调用，* 这跟Struts2里面的拦截器的执行过程有点像，* 只是Struts2里面的intercept方法中要手动的调用ActionInvocation的invoke方法，* Struts2中调用ActionInvocation的invoke方法就是调用下一个Interceptor或者是调用action，* 然后要在Interceptor之前调用的内容都写在调用invoke之前，要在Interceptor之后调用的内容都写在调用invoke方法之后。*/@Overridepublic void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)throws Exception &#123;&#125;/*** 该方法也是需要当前对应的Interceptor的preHandle方法的返回值为true时才会执行。* 该方法将在整个请求完成之后，也就是DispatcherServlet渲染了视图执行， 这个方法的主要作用是用于清理资源的，*/@Overridepublic void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)throws Exception &#123;&#125; 配置123456789101112131415&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"xmlns:mvc=\"http://www.springframework.org/schema/mvc\"xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.1.xsdhttp://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd\"&gt;&lt;mvc:interceptors&gt;&lt;!-- 日志拦截器 --&gt;&lt;mvc:interceptor&gt;&lt;mvc:mapping path=\"/**\" /&gt;&lt;mvc:exclude-mapping path=\"/static/**\" /&gt;&lt;bean class=\"拦截器java代码路径\" /&gt;&lt;/mvc:interceptor&gt;&lt;/mvc:interceptors&gt;&lt;/beans&gt; 工作流程一个拦截器，只有preHandle方法返回true，postHandle、afterCompletion才有可能被执行；如果preHandle方法返回false，则该拦截器的postHandle、afterCompletion必然不会被执行。 假设我们有两个拦截器，例如叫Interceptor1和Interceptor2，当一个请求过来，正常的流程和中断的流程分别如下。 正常流程注意两个拦截器在执行preHandle方法和执行postHandle、afterCompletion方法时，顺序是颠倒的。 1234567891011121314151. Interceptor1.preHandle2. Interceptor2.preHandle3. Controller处理请求4. Interceptor2.postHandle5. Interceptor1.postHandle6. 渲染视图7. Interceptor2.afterCompletion8. Interceptor1.afterCompletion 中断流程假设执行Interceptor2.preHandle中报错，那么流程被中断，之前被执行过的拦截器的afterCompletion仍然会执行。在本例中，即执行了Interceptor1.afterCompletion。 12345671. Interceptor1.preHandle2. Interceptor2.preHandle//中间流程被中断，不再执行3. Interceptor1.afterCompletion 与过滤器共存时的执行顺序拦截器是在DispatcherServlet这个servlet中执行的，因此所有的请求最先进入Filter，最后离开Filter。其顺序如下。 Filter-&gt;Interceptor.preHandle-&gt;Handler-&gt;Interceptor.postHandle-&gt;Interceptor.afterCompletion-&gt;Filter 应用场景拦截器本质上是面向切面编程（AOP），符合横切关注点的功能都可以放在拦截器中来实现，主要的应用场景包括： 登录验证，判断用户是否登录。权限验证，判断用户是否有权限访问资源。日志记录，记录请求日志，以便统计请求访问量。处理cookie、本地化、国际化、主题等。性能监控，监控请求处理时长等。 spring boot配置拦截器为了使自定义的拦截器生效，需要注册拦截器到spring容器中，具体的做法是继承WebMvcConfigurerAdapter类，覆盖其addInterceptors(InterceptorRegistry registry)方法。最后别忘了把Bean注册到Spring容器中，可以选择@Component 或者 @Configuration 123456789101112131415@Componentpublic class InterceptorConfiguration extends WebMvcConfigurerAdapter&#123;@Overridepublic void addInterceptors(InterceptorRegistry registry) &#123;// 注册拦截器InterceptorRegistration ir = registry.addInterceptor(new LoginInterceptor());// 配置拦截的路径ir.addPathPatterns(&quot;/**&quot;);// 配置不拦截的路径ir.excludePathPatterns(&quot;/**.html&quot;);// 还可以在这里注册其它的拦截器//registry.addInterceptor(new OtherInterceptor()).addPathPatterns(&quot;/**&quot;);&#125;&#125;","categories":[],"tags":[]},{"title":"JAVA动态代理","slug":"动态代理","date":"2018-02-09T09:47:55.000Z","updated":"2018-03-10T18:07:33.000Z","comments":true,"path":"2018/02/09/动态代理/","link":"","permalink":"https://killgc.github.io/shortfeng/2018/02/09/动态代理/","excerpt":"","text":"JAVA动态代理 静态代理 jdk动态代理 cglib动态代理 标签（空格分隔）： jdk动态代理 cglib jdk动态代理 jdk动态代理机制中，有两个重要的类或接口，一个是Proxy，另一个是InvocationHandler Proxy类Proxy类是用来动态创建一个代理对象，经常使用newProxyInstance静态方法12345public static Object newProxyInstance(ClassLoader loader,Class&lt;?&gt;[] interfaces,InvocationHandler h) throws IllegalArgumentException参数：loader 类加载器interfaces 真实类所拥有的所有接口的数组h 调用处理器对象 InvocationHandler接口InvocationHandler接口只有唯一一个invoke方法12345public Object invoke(Object proxy, Method method, Object[] args) throws Throwable;参数：proxy 代理类对象method 调用真实类对象某个方法对应的method对象args 调用真实类对象某个方法传人的参数 示例1、主题接口 123456package com.example.ford.proxy;public interface Subject &#123; String sayHello(String name); String sayGoodBye();&#125; 2、 被代理类 12345678910111213package com.example.ford.proxy;public class RealSubject implements Subject&#123; @Override public String sayHello(String name) &#123; return \"hello \"+name; &#125; @Override public String sayGoodBye() &#123; return \" good bye\"; &#125;&#125; 3、调用处理器 123456789101112131415161718192021package com.example.ford.proxy;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;public class TestInvocationHandler implements InvocationHandler&#123; private Subject subject; public TestInvocationHandler(Subject subject)&#123; this.subject = subject; &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; System.out.println(proxy.getClass()); System.out.println(\"开始执行 \"+method.getName()); Object returnValue = method.invoke(subject,args); System.out.println(\"结束执行 \"+method.getName()); return returnValue; &#125;&#125; 3、测试 12345678910111213141516171819package com.example.ford.proxy;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Proxy;public class TestMain &#123; public static void main(String[] args) &#123; Subject subject = new RealSubject(); InvocationHandler handler = new TestInvocationHandler(subject); Class cls = subject.getClass(); ClassLoader loader = cls.getClassLoader(); Class[] interfaces = cls.getInterfaces(); Subject proxy = (Subject) Proxy.newProxyInstance(loader, interfaces, handler); String returnValue1 = proxy.sayHello(\"changfeng\"); System.out.println(returnValue1); String returnValue2 = proxy.sayGoodBye(); System.out.println(returnValue2); &#125;&#125; 测试结果 12345678class com.sun.proxy.$Proxy0开始执行 sayHello结束执行 sayHellohello changfengclass com.sun.proxy.$Proxy0开始执行 sayGoodBye结束执行 sayGoodBye good bye 原理生成代理类类文件： 1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.example.ford.proxy;import sun.misc.ProxyGenerator;import java.io.File;import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.IOException;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Proxy;public class JDKProxyTest &#123; public static void main(String[] args)&#123; Subject subject = new RealSubject(); InvocationHandler handler = new TestInvocationHandler(subject); Class cls = subject.getClass(); ClassLoader loader = cls.getClassLoader(); Class[] interfaces = cls.getInterfaces(); Subject proxy = (Subject) Proxy.newProxyInstance(loader, interfaces, handler); createProxyClassFile(); &#125; private static void createProxyClassFile()&#123; String name = \"ProxySubject\"; byte[] data = ProxyGenerator.generateProxyClass(name,new Class[]&#123;Subject.class&#125;); FileOutputStream out =null; try &#123; out = new FileOutputStream(name+\".class\"); System.out.println((new File(\"hello\")).getAbsolutePath()); out.write(data); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;finally &#123; if(null!=out) try &#123; out.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 利用jd-gui反编译代理类class文件： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122import com.example.ford.proxy.Subject;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;import java.lang.reflect.UndeclaredThrowableException;public final class ProxySubject extends Proxy implements Subject&#123; private static Method m1; private static Method m3; private static Method m2; private static Method m4; private static Method m0; public ProxySubject(InvocationHandler paramInvocationHandler) &#123; super(paramInvocationHandler); &#125; public final boolean equals(Object paramObject) &#123; try &#123; return ((Boolean)this.h.invoke(this, m1, new Object[] &#123; paramObject &#125;)).booleanValue(); &#125; catch (Error|RuntimeException localError) &#123; throw localError; &#125; catch (Throwable localThrowable) &#123; throw new UndeclaredThrowableException(localThrowable); &#125; &#125; public final String sayHello(String paramString) &#123; try &#123; return (String)this.h.invoke(this, m3, new Object[] &#123; paramString &#125;); &#125; catch (Error|RuntimeException localError) &#123; throw localError; &#125; catch (Throwable localThrowable) &#123; throw new UndeclaredThrowableException(localThrowable); &#125; &#125; public final String toString() &#123; try &#123; return (String)this.h.invoke(this, m2, null); &#125; catch (Error|RuntimeException localError) &#123; throw localError; &#125; catch (Throwable localThrowable) &#123; throw new UndeclaredThrowableException(localThrowable); &#125; &#125; public final String sayGoodBye() &#123; try &#123; return (String)this.h.invoke(this, m4, null); &#125; catch (Error|RuntimeException localError) &#123; throw localError; &#125; catch (Throwable localThrowable) &#123; throw new UndeclaredThrowableException(localThrowable); &#125; &#125; public final int hashCode() &#123; try &#123; return ((Integer)this.h.invoke(this, m0, null)).intValue(); &#125; catch (Error|RuntimeException localError) &#123; throw localError; &#125; catch (Throwable localThrowable) &#123; throw new UndeclaredThrowableException(localThrowable); &#125; &#125; static &#123; try &#123; m1 = Class.forName(\"java.lang.Object\").getMethod(\"equals\", new Class[] &#123; Class.forName(\"java.lang.Object\") &#125;); m3 = Class.forName(\"com.example.ford.proxy.Subject\").getMethod(\"sayHello\", new Class[] &#123; Class.forName(\"java.lang.String\") &#125;); m2 = Class.forName(\"java.lang.Object\").getMethod(\"toString\", new Class[0]); m4 = Class.forName(\"com.example.ford.proxy.Subject\").getMethod(\"sayGoodBye\", new Class[0]); m0 = Class.forName(\"java.lang.Object\").getMethod(\"hashCode\", new Class[0]); return; &#125; catch (NoSuchMethodException localNoSuchMethodException) &#123; throw new NoSuchMethodError(localNoSuchMethodException.getMessage()); &#125; catch (ClassNotFoundException localClassNotFoundException) &#123; throw new NoClassDefFoundError(localClassNotFoundException.getMessage()); &#125; &#125;&#125; 123456789101112131415public final String sayHello(String paramString)&#123; try &#123; return (String)this.h.invoke(this, m3, new Object[] &#123; paramString &#125;); &#125; catch (Error|RuntimeException localError) &#123; throw localError; &#125; catch (Throwable localThrowable) &#123; throw new UndeclaredThrowableException(localThrowable); &#125;&#125;","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2018-02-07T16:25:49.000Z","updated":"2018-02-07T16:25:49.000Z","comments":true,"path":"2018/02/08/hello-world/","link":"","permalink":"https://killgc.github.io/shortfeng/2018/02/08/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}