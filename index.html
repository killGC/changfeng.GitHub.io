<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/shortfeng/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/shortfeng/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/shortfeng/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/shortfeng/favicon.ico?v=5.1.2" />






<meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="https://killgc.github.io/shortfeng/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/shortfeng/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://killgc.github.io/shortfeng/"/>





  <title>Hexo</title>
  














</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/shortfeng/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hexo</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/shortfeng/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/shortfeng/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/shortfeng/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://killgc.github.io/shortfeng/shortfeng/2018/04/04/支付/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="changfeng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/shortfeng/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/shortfeng/2018/04/04/支付/" itemprop="url">支付</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-04T00:03:00+08:00">
                2018-04-04
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="支付系统的思考"><a href="#支付系统的思考" class="headerlink" title="支付系统的思考"></a>支付系统的思考</h2><hr>
<p>支付系统特点：</p>
<blockquote>
<ul>
<li>写多读少，读写分离方案效果不明显</li>
<li>事务强一致性，事务ACID，强调Consistency（一致性）和Availability（可用性），数据库一般用关系数据库。</li>
</ul>
</blockquote>
<h4 id="防重提交策略"><a href="#防重提交策略" class="headerlink" title="防重提交策略"></a>防重提交策略</h4><blockquote>
<ul>
<li><p>乐观锁：通过唯一索引锁住记录（行级锁），UPDATE tab1 SET col1=1,version=version+1 WHERE id=#id# and version=#version#</p>
</li>
<li><p>悲观锁：select * from table_xxx where id=’xxx’ for update，id字段一定是主键或者唯一索引，不然是锁表，悲观锁使用时一般伴随事务一起使用，数据锁定时间可能会很长，根据实际情况选用</p>
</li>
<li><p>防重表：唯一索引导致插入失败</p>
</li>
<li>分布式锁：redis分布式锁</li>
<li>Token：分为两步，第一步申请Token，第二步拿申请到Token发起请求。可以设置Token过期时间</li>
<li>支付缓冲：把支付请求快速接下来，后续再启异步任务处理，可以过滤掉重复的支付订单。优点是<br>高吞吐；缺点是不能及时返回处理结果，后续需要监听支付结果的异步返回</li>
<li>状态机：如果状态机已经处于下一个状态，这时候来了一个上一个状态的变更，理论上是不能够变更的</li>
</ul>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://killgc.github.io/shortfeng/shortfeng/2018/04/01/redis/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="changfeng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/shortfeng/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/shortfeng/2018/04/01/redis/" itemprop="url">redis</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-01T19:58:26+08:00">
                2018-04-01
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><hr>
<h4 id="Redis持久化"><a href="#Redis持久化" class="headerlink" title="Redis持久化"></a>Redis持久化</h4><blockquote>
<ul>
<li><p>RDB持久化：在指定的时间间隔内生成数据集的时间点快照</p>
</li>
<li><p>AOF持久化：记录服务器执行的所有写操作命令，并在服务器启动时，通过重新执行这些命令来还原数据集。 AOF 文件中的命令全部以 Redis 协议的格式来保存，新命令会被追加到文件的末尾</p>
</li>
</ul>
</blockquote>
<h5 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h5><p>优点：</p>
<blockquote>
<ul>
<li>适合用于备份</li>
<li>适用于灾难恢复</li>
<li>父进程在保存RDB文件时唯一要做的就是fork出一个子进程，然后这个子进程就会处理接下来的所有保存工作，父进程无须执行任何磁盘I/O操作</li>
<li>RDB 在恢复大数据集时的速度比 AOF 的恢复速度要快</li>
</ul>
</blockquote>
<p>缺点：</p>
<blockquote>
<ul>
<li><p>如果你需要尽量避免在服务器故障时丢失数据，那么 RDB 不适合你。 虽然 Redis 允许你设置不同的保存点（save point）来控制保存 RDB 文件的频率， 但是， 因为RDB 文件需要保存整个数据集的状态， 所以它并不是一个轻松的操作。 因此你可能会至少 5 分钟才保存一次 RDB 文件。 在这种情况下， 一旦发生故障停机， 你就可能会丢失好几分钟的数据</p>
</li>
<li><p>每次保存 RDB 的时候，Redis 都要 fork() 出一个子进程，并由子进程来进行实际的持久化工作。 在数据集比较庞大时， fork() 可能会非常耗时，造成服务器在某某毫秒内停止处理客户端； 如果数据集非常巨大，并且 CPU 时间非常紧张的话，那么这种停止时间甚至可能会长达整整一秒。 虽然 AOF 重写也需要进行 fork() ，但无论 AOF 重写的执行间隔有多长，数据的耐久性都不会有任何损失</p>
</li>
</ul>
</blockquote>
<h5 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h5><p>append-only file，AOF</p>
<p>优点：</p>
<blockquote>
<ul>
<li><p>使用 AOF 持久化会让 Redis 变得非常耐久，AOF 的默认策略为每秒钟 fsync 一次</p>
</li>
<li><p>redis-check-aof 工具也可以轻易地修复因为某些原因而包含了未写入完整的命令</p>
</li>
<li><p>Redis 可以在 AOF 文件体积变得过大时，自动地在后台对 AOF 进行重写，整个重写操作是绝对安全的</p>
</li>
<li><p>AOF 文件有序地保存了对数据库执行的所有写入操作，容易被人读懂</p>
</li>
</ul>
</blockquote>
<p>缺点：</p>
<blockquote>
<ul>
<li>对于相同的数据集来说，AOF 文件的体积通常要大于 RDB 文件的体积</li>
<li>根据所使用的 fsync 策略，AOF 的速度可能会慢于 RDB</li>
</ul>
</blockquote>
<p>修改配置文件来打开 AOF 功能：appendonly yes </p>
<p>配置 Redis 多久才将数据 fsync 到磁盘一次。有三个选项：</p>
<blockquote>
<ul>
<li>每次有新命令追加到 AOF 文件时就执行一次 fsync ：非常慢，也非常安全。</li>
<li>每秒 fsync 一次：足够快（和使用 RDB 持久化差不多），并且在故障时只会丢失 1 秒钟的数据。</li>
<li>从不 fsync ：将数据交给操作系统来处理。更快，也更不安全的选择。<br>推荐（并且也是默认）的措施为每秒 fsync 一次， 这种 fsync 策略可以兼顾速度和安全性</li>
</ul>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://killgc.github.io/shortfeng/shortfeng/2018/03/30/分布式事务/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="changfeng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/shortfeng/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/shortfeng/2018/03/30/分布式事务/" itemprop="url">分布式事务</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-30T23:40:48+08:00">
                2018-03-30
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h2><hr>
<blockquote>
<ul>
<li>事务补偿机制：事务链中的任何一个正向事务操作，都必须存在一个完全符合回滚规则的可逆事务，补偿过程作为一个服务调用过程同样存在调用不成功的情况，这个时候需要通过重试的机制来保证补偿的成功率。当然这也就要求补偿操作本身具备幂等性</li>
<li>柔性事务：分布式事务适用柔性事务</li>
<li>刚性事务：本地事务采用刚性事务</li>
<li>幂等性：不具有幂等性的操作，需要存储操作的执行结果，当执行操作的时候，查询是否已执行过，如果执行过直接返回上一次执行的结果，否则执行操作</li>
</ul>
</blockquote>
<h4 id="重试策略"><a href="#重试策略" class="headerlink" title="重试策略"></a>重试策略</h4><p>如果只是一味的失败就立即重试会给工作服务造成不必要的压力，我们要根据服务执行失败的原因来选择不同的重试策略</p>
<p>重试操作一般会指定重试次数上线，如果重试次数达到了上限就不再进行重试了。这个时候应该通过一种手段通知相关人员进行处理。</p>
<p>对于等待重试的策略如果重试时仍然错误，可逐渐增加等待的时间，直到达到一个上限后，以上限作为等待时间。</p>
<p>如果某个时刻聚集了大量需要重试的操作，补偿框架需要控制请求的流量，以防止对工作服务造成过大的压力</p>
<blockquote>
<ul>
<li>如果失败的原因不是暂时性的，由于业务因素导致（如业务要素检查失败）的业务错误，这类错误是不会重发就能自动恢复的，那么应该立即终止重试</li>
<li>如果错误的原因是一些罕见的异常，比如因为网络传输过程出现数据丢失或者错误，应该立即再次重试，因为类似的错误一般很少会再次发生</li>
<li>如果错误的原因是系统繁忙（比如http协议返回的500或者另外约定的返回码）或者超时，这个时候需要等待一些时间再重试。</li>
</ul>
</blockquote>
<p>分布式事务实现方案：</p>
<blockquote>
<ul>
<li>两阶段提交(2PC)</li>
<li>TCC(Try-Confirm-Cancel)</li>
<li>异步确保型</li>
<li>最大努力通知型</li>
</ul>
</blockquote>
<h4 id="两阶段提交"><a href="#两阶段提交" class="headerlink" title="两阶段提交"></a>两阶段提交</h4><h4 id="TCC"><a href="#TCC" class="headerlink" title="TCC"></a>TCC</h4><p>适用场景：</p>
<blockquote>
<ul>
<li>严格一致性</li>
<li>执行时间较短</li>
<li>实时性要求高</li>
</ul>
</blockquote>
<h4 id="异步确保型"><a href="#异步确保型" class="headerlink" title="异步确保型"></a>异步确保型</h4><p>消息可靠、消息重复消费<br>适用场景：</p>
<blockquote>
<ul>
<li>执行周期较长</li>
<li>实时性要求不高</li>
</ul>
</blockquote>
<h4 id="最大努力通知型"><a href="#最大努力通知型" class="headerlink" title="最大努力通知型"></a>最大努力通知型</h4>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://killgc.github.io/shortfeng/shortfeng/2018/03/27/Dubbo/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="changfeng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/shortfeng/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/shortfeng/2018/03/27/Dubbo/" itemprop="url">Dubbo</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-27T23:00:36+08:00">
                2018-03-27
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="dubbo"><a href="#dubbo" class="headerlink" title="dubbo"></a>dubbo</h2><hr>
<h4 id="循环依赖问题"><a href="#循环依赖问题" class="headerlink" title="循环依赖问题"></a>循环依赖问题</h4><p>1、check属性 </p>
<blockquote>
<ul>
<li>默认check=true：dubbo缺省会在启动时检查依赖的服务是否可用（是否有提供者），不可用时会抛出异常，阻止Spring初始化完成，以便上线时，能及早发现问题</li>
<li>check=false：关闭检查依赖的服务是否可用</li>
</ul>
</blockquote>
<p>以下场景需关闭检查：</p>
<p>出现循环依赖，必须有一方先启动时；或者测试时，有些服务不关心；Spring容器是懒加载或者通过API编程延迟引用服务</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">关闭某个服务的启动检查：</span><br><span class="line">&lt;dubbo:reference</span><br><span class="line"><span class="class"><span class="keyword">interface</span></span>=<span class="string">"com.foo.BarService"</span></span><br><span class="line">check=<span class="string">"false"</span>/&gt;</span><br><span class="line"></span><br><span class="line">关闭所有服务的启动时检查：</span><br><span class="line">&lt;dubbo:consumer</span><br><span class="line">check=<span class="string">"false"</span>/&gt;</span><br><span class="line"></span><br><span class="line">关闭注册中心启动时检查：(注册订阅失败时报错)</span><br><span class="line">&lt;dubbo:registry</span><br><span class="line">check=<span class="string">"false"</span>/&gt;</span><br><span class="line"></span><br><span class="line">java -D参数：</span><br><span class="line">dubbo.reference.com.foo.BarService.check=<span class="keyword">false</span></span><br><span class="line">dubbo.reference.check=<span class="keyword">false</span></span><br><span class="line">dubbo.consumer.check=<span class="keyword">false</span></span><br><span class="line">dubbo.registry.check=<span class="keyword">false</span></span><br><span class="line"></span><br><span class="line">dubbo.properties配置：</span><br><span class="line">dubbo.reference.com.foo.BarService.check=<span class="keyword">false</span></span><br><span class="line">dubbo.reference.check=<span class="keyword">false</span></span><br><span class="line">dubbo.consumer.check=<span class="keyword">false</span></span><br><span class="line">dubbo.registry.check=<span class="keyword">false</span></span><br></pre></td></tr></table></figure>
<p>区别：</p>
<blockquote>
<ul>
<li><p>dubbo.reference.check=false，强制改变所有reference的check值，就算配置中有声明，也会被覆盖。</p>
</li>
<li><p>dubbo.consumer.check=false，是设置check的缺省值，如果配置中有显式的声明，如：<dubbo:reference check="true">，不会受影响。</dubbo:reference></p>
</li>
<li><p>dubbo.registry.check=false，前面两个都是指订阅成功，但提供者列表是否为空是否报错，如果注册订阅失败时，也允许启动，需使用此选项，将在后台定时重试。</p>
</li>
</ul>
</blockquote>
<p>2、init属性</p>
<p>如果需要饥饿加载，即没有人引用也立即生成动态代理，可用配置：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;dubbo:reference </span><br><span class="line"><span class="class"><span class="keyword">interface</span></span>=<span class="string">"com.foo.BarService"</span> init=<span class="string">"true"</span>/&gt;</span><br></pre></td></tr></table></figure>
<h4 id="集群容错"><a href="#集群容错" class="headerlink" title="集群容错"></a>集群容错</h4><p>集群调用失败时，dubbo提供了多种容错方案，默认为failover重试</p>
<p><img src="http://www.uml.org.cn/zjjs/images/2015091041.jpg" alt="cmd-markdown-logo"></p>
<h5 id="各节点关系："><a href="#各节点关系：" class="headerlink" title="各节点关系："></a>各节点关系：</h5><blockquote>
<ul>
<li><p>这里的Invoker是Provider的一个可调用Service的抽象，Invoker封装了Provider地址及Service接口信息。</p>
</li>
<li><p>Directory代表多个Invoker，可以把它看成List<invoker>，但与List不同的是，它的值可能是动态变化的，比如注册中心推送变更。</invoker></p>
</li>
<li><p>Cluster将Directory中的多个Invoker伪装成一个Invoker，对上层透明，伪装过程包含了容错逻辑，调用失败后，重试另一个。</p>
</li>
<li><p>Router负责从多个Invoker中按路由规则选出子集，比如读写分离，应用隔离等。</p>
</li>
<li><p>LoadBalance负责从多个Invoker中选出具体的一个用于本次调用，选的过程包含了负载均衡算法，调用失败后，需要重选。</p>
</li>
</ul>
</blockquote>
<h5 id="集群容错模式："><a href="#集群容错模式：" class="headerlink" title="集群容错模式："></a>集群容错模式：</h5><blockquote>
<ul>
<li><p>Failover Cluster：失败自动切换，当出现失败，重试其它服务器。(缺省)，通常用于读操作，但重试会带来更长延迟。可通过retries=”2”来设置重试次数(不含第一次)。</p>
</li>
<li><p>Failfast Cluster：快速失败，只发起一次调用，失败立即报错。<br>通常用于非幂等性的写操作，比如新增记录。</p>
</li>
<li><p>Failsafe Cluster：失败安全，出现异常时，直接忽略。通常用于写入审计日志等操作。</p>
</li>
<li><p>Failback Cluster：失败自动恢复，后台记录失败请求，定时重发。<br>通常用于消息通知操作。</p>
</li>
<li><p>Forking Cluster：并行调用多个服务器，只要一个成功即返回。<br>通常用于实时性要求较高的读操作，但需要浪费更多服务资源。可通过forks=”2”来设置最大并行数。</p>
</li>
<li><p>Broadcast Cluster：广播调用所有提供者，逐个调用，任意一台报错则报错。(2.1.0开始支持)，通常用于通知所有提供者更新缓存或日志等本地资源信息。</p>
</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">重试次数配置（failover集群模式生效）：</span><br><span class="line">&lt;dubbo:service</span><br><span class="line">retries=<span class="string">"2"</span>/&gt;</span><br><span class="line"></span><br><span class="line">&lt;dubbo:reference</span><br><span class="line">retries=<span class="string">"2"</span>/&gt;</span><br><span class="line"></span><br><span class="line">&lt;dubbo:reference&gt;</span><br><span class="line"></span><br><span class="line">&lt;dubbo:method</span><br><span class="line">name=<span class="string">"findFoo"</span></span><br><span class="line">retries=<span class="string">"2"</span>/&gt;</span><br><span class="line">&lt;/dubbo:reference&gt;</span><br><span class="line"></span><br><span class="line">集群模式配置：</span><br><span class="line">&lt;dubbo:service</span><br><span class="line">cluster=<span class="string">"failsafe"</span>/&gt;</span><br><span class="line"></span><br><span class="line">&lt;dubbo:reference</span><br><span class="line">cluster=<span class="string">"failsafe"</span>/&gt;</span><br></pre></td></tr></table></figure>
<h5 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h5><p>在集群负载均衡时，Dubbo提供了多种均衡策略，缺省为random随机调用。</p>
<blockquote>
<ul>
<li><p>Random LoadBalance：随机，按权重设置随机概率。<br>在一个截面上碰撞的概率高，但调用量越大分布越均匀，而且按概率使用权重后也比较均匀，有利于动态调整提供者权重。</p>
</li>
<li><p>RoundRobin LoadBalance<br>轮循，按公约后的权重设置轮循比率。<br>存在慢的提供者累积请求问题，比如：第二台机器很慢，但没挂，当请求调到第二台时就卡在那，久而久之，所有请求都卡在调到第二台上。</p>
</li>
<li><p>LeastActive LoadBalance<br>最少活跃调用数，相同活跃数的随机，活跃数指调用前后计数差。<br>使慢的提供者收到更少请求，因为越慢的提供者的调用前后计数差会越大。</p>
</li>
<li><p>ConsistentHash LoadBalance<br>一致性Hash，相同参数的请求总是发到同一提供者。<br>当某一台提供者挂时，原本发往该提供者的请求，基于虚拟节点，平摊到其它提供者，不会引起剧烈变动。</p>
</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">缺省只对第一个参数Hash，如果要修改，请配置</span><br><span class="line">&lt;dubbo:parameter key=<span class="string">"hash.arguments"</span> value=<span class="string">"0,1"</span> /&gt;</span><br><span class="line">缺省用<span class="number">160</span>份虚拟节点，如果要修改，请配置</span><br><span class="line">&lt;dubbo:parameter key=<span class="string">"hash.nodes"</span> value=<span class="string">"320"</span> /&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;dubbo:service <span class="class"><span class="keyword">interface</span></span>=<span class="string">"..."</span> </span><br><span class="line">loadbalance=<span class="string">"roundrobin"</span>/&gt;</span><br><span class="line"></span><br><span class="line">&lt;dubbo:reference</span><br><span class="line"><span class="class"><span class="keyword">interface</span></span>=<span class="string">"..."</span></span><br><span class="line">loadbalance=<span class="string">"roundrobin"</span>/&gt;</span><br><span class="line"></span><br><span class="line">&lt;dubbo:service</span><br><span class="line"><span class="class"><span class="keyword">interface</span></span>=<span class="string">"..."</span>&gt;</span><br><span class="line"></span><br><span class="line">&lt;dubbo:service <span class="class"><span class="keyword">interface</span></span>=<span class="string">"..."</span>&gt;</span><br><span class="line">	&lt;dubbo:method name=<span class="string">"..."</span> loadbalance=<span class="string">"roundrobin"</span>/&gt;</span><br><span class="line">&lt;/dubbo:service&gt;</span><br><span class="line"></span><br><span class="line">&lt;dubbo:reference <span class="class"><span class="keyword">interface</span></span>=<span class="string">"..."</span>&gt;</span><br><span class="line">&lt;dubbo:method name=<span class="string">"..."</span> loadbalance=<span class="string">"roundrobin"</span>/&gt;</span><br><span class="line">&lt;/dubbo:reference&gt;</span><br></pre></td></tr></table></figure>
<h4 id="线程模型"><a href="#线程模型" class="headerlink" title="线程模型"></a>线程模型</h4><p><img src="http://www.uml.org.cn/zjjs/images/2015091042.jpg" alt="cmd-markdown-logo"></p>
<p>如果事件处理的逻辑能迅速完成，并且不会发起新的IO请求，比如只是在内存中记个标识，则直接在IO线程上处理更快，因为减少了线程池调度。</p>
<p>但如果事件处理逻辑较慢，或者需要发起新的IO请求，比如需要查询数据库，则必须派发到线程池，否则IO线程阻塞，将导致不能接收其它请求。</p>
<p>如果用IO线程处理事件，又在事件处理过程中发起新的IO请求，比如在连接事件中发起登录请求，会报“可能引发死锁”异常，但不会真死锁。</p>
<h5 id="Dispatcher"><a href="#Dispatcher" class="headerlink" title="Dispatcher"></a>Dispatcher</h5><blockquote>
<ul>
<li><p>all 所有消息都派发到线程池，包括请求，响应，连接事件，断开事件，心跳等。</p>
</li>
<li><p>direct 所有消息都不派发到线程池，全部在IO线程上直接执行。</p>
</li>
<li><p>message 只有请求响应消息派发到线程池，其它连接断开事件，心跳等消息，直接在IO线程上执行。</p>
</li>
<li><p>execution 只请求消息派发到线程池，不含响应，响应和其它连接断开事件，心跳等消息，直接在IO线程上执行。</p>
</li>
<li><p>connection 在IO线程上，将连接断开事件放入队列，有序逐个执行，其它消息派发到线程池。</p>
</li>
</ul>
</blockquote>
<h5 id="ThreadPool"><a href="#ThreadPool" class="headerlink" title="ThreadPool"></a>ThreadPool</h5><blockquote>
<ul>
<li><p>fixed 固定大小线程池，启动时建立线程，不关闭，一直持有。(缺省)</p>
</li>
<li><p>cached 缓存线程池，空闲一分钟自动删除，需要时重建。</p>
</li>
<li><p>limited 可伸缩线程池，但池中的线程数只会增长不会收缩。(为避免收缩时突然来了大流量引起的性能问题)。</p>
</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dubbo:protocol name=<span class="string">"dubbo"</span></span><br><span class="line">dispatcher=<span class="string">"all"</span></span><br><span class="line">threadpool=<span class="string">"fixed"</span></span><br><span class="line">threads=<span class="string">"100"</span>/&gt;</span><br></pre></td></tr></table></figure>
<h4 id="直连提供者"><a href="#直连提供者" class="headerlink" title="直连提供者"></a>直连提供者</h4><p>在开发及测试环境下，经常需要绕过注册中心，只测试指定服务提供者，这时候可能需要点对点直连，点对点直联方式，将以服务接口为单位，忽略注册中心的提供者列表</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">配置url指向提供者，将绕过注册中心，多个地址用分号隔开</span><br><span class="line">&lt;dubbo:reference</span><br><span class="line">id=<span class="string">"xxxService"</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span></span>=<span class="string">"com.alibaba.xxx.XxxService"</span></span><br><span class="line">url=<span class="string">"dubbo://localhost:20890"</span>/&gt;</span><br><span class="line"></span><br><span class="line">在JVM启动参数中加入-D参数映射服务地址，此配置优先级最高</span><br><span class="line">java</span><br><span class="line"> -Dcom.alibaba.xxx.XxxService=dubbo:<span class="comment">//localhost:20890</span></span><br><span class="line"> </span><br><span class="line"> 如果服务比较多，也可以用文件映射</span><br><span class="line"> 用-Ddubbo.resolve.file指定映射文件路径，</span><br><span class="line"> 此配置优先级高于&lt;dubbo:reference&gt;中的配置</span><br><span class="line"> 如：</span><br><span class="line"> java</span><br><span class="line"> -Ddubbo.resolve.file=xxx.properties</span><br><span class="line"> </span><br><span class="line"> 然后在映射文件xxx.properties中加入：</span><br><span class="line"> com.alibaba.xxx.XxxService=dubbo:<span class="comment">//localhost:20890</span></span><br></pre></td></tr></table></figure>
<h5 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h5><p>为了避免复杂化线上环境，不要在线上使用这个功能，只应在测试阶段使用</p>
<h4 id="只订阅"><a href="#只订阅" class="headerlink" title="只订阅"></a>只订阅</h4><h5 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h5><p>为方便开发测试，经常会在线下共用一个所有服务可用的注册中心，这时，如果一个正在开发中的服务提供者注册，可能会影响消费者不能正常运行。</p>
<h5 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h5><p>可以让服务提供者开发方，只订阅服务(开发的服务可能依赖其它服务)，而不注册正在开发的服务，通过直连测试正在开发的服务。</p>
<p><img src="http://www.uml.org.cn/zjjs/images/2015091044.jpg" alt="cmd-markdown-logo"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">禁用注册配置：</span><br><span class="line">&lt;dubbo:registry</span><br><span class="line">address=<span class="string">"10.20.153.10:9090"</span></span><br><span class="line">register=<span class="string">"false"</span></span><br><span class="line">/&gt;</span><br><span class="line">或者</span><br><span class="line">&lt;dubbo:registry</span><br><span class="line">address=<span class="string">"10.20.153.10:9090?register=false"</span></span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure>
<h4 id="只注册"><a href="#只注册" class="headerlink" title="只注册"></a>只注册</h4><h5 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h5><p>如果有两个镜像环境，两个注册中心，有一个服务只在其中一个注册中心有部署，另一个注册中心还没来得及部署，而两个注册中心的其它应用都需要依赖此服务，所以需要将服务同时注册到两个注册中心，但却不能让此服务同时依赖两个注册中心的其它服务。</p>
<h5 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h5><p>可以让服务提供者方，只注册服务到另一注册中心，而不从另一注册中心订阅服务</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;dubbo:registry</span><br><span class="line">id=<span class="string">"hzRegistry"</span></span><br><span class="line">address=<span class="string">"10.20.153.10:9090"</span></span><br><span class="line">/&gt;</span><br><span class="line">&lt;dubbo:registry</span><br><span class="line">id=<span class="string">"qdRegistry"</span></span><br><span class="line">address=<span class="string">"10.20.141.150:9090"</span></span><br><span class="line">subscribe=<span class="string">"false"</span></span><br><span class="line">/&gt;</span><br><span class="line"></span><br><span class="line">或者</span><br><span class="line"></span><br><span class="line">&lt;dubbo:registry</span><br><span class="line">id=<span class="string">"hzRegistry"</span></span><br><span class="line">address=<span class="string">"10.20.153.10:9090"</span></span><br><span class="line">/&gt;</span><br><span class="line">&lt;dubbo:registry</span><br><span class="line">id=<span class="string">"qdRegistry"</span></span><br><span class="line">address=<span class="string">"10.20.141.150:9090?subscribe=false"</span></span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure>
<h4 id="静态服务"><a href="#静态服务" class="headerlink" title="静态服务"></a>静态服务</h4><p>有时候希望人工管理服务提供者的上线和下线，此时需将注册中心标识为非动态管理模式</p>
<p>服务提供者初次注册时为禁用状态，需人工启用，断线时，将不会被自动删除，需人工禁用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;dubbo:registry</span><br><span class="line">address=<span class="string">"10.20.141.150:9090"</span></span><br><span class="line">dynamic=<span class="string">"false"</span></span><br><span class="line">/&gt;</span><br><span class="line"></span><br><span class="line">或者</span><br><span class="line">&lt;dubbo:registry</span><br><span class="line">address=<span class="string">"10.20.141.150:9090?dynamic=false"</span></span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure>
<h4 id="多协议"><a href="#多协议" class="headerlink" title="多协议"></a>多协议</h4><p>(1) 不同服务不同协议</p>
<p>不同服务在性能上适用不同协议进行传输，比如大数据用短连接协议，小数据大并发用长连接协议</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;</span><br><span class="line">&lt;beans xmlns=<span class="string">"http://www.springframework.org/schema/beans"</span></span><br><span class="line">    xmlns:xsi=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="line">    xmlns:dubbo=<span class="string">"http://code.alibabatech.com/schema/dubbo"</span></span><br><span class="line">    xsi:schemaLocation=<span class="string">"http://www.springframework.org/schema/beans</span></span><br><span class="line"><span class="string">http://www.springframework.org/schema/beans/spring-beans.xsd</span></span><br><span class="line"><span class="string">http://code.alibabatech.com/schema/dubbohttp://code.alibabatech.com/schema/dubbo/dubbo.xsd"</span>&gt;</span><br><span class="line"> </span><br><span class="line">    &lt;dubbo:application name=<span class="string">"world"</span>  /&gt;</span><br><span class="line">    &lt;dubbo:registry id=<span class="string">"registry"</span> address=<span class="string">"10.20.141.150:9090"</span> username=<span class="string">"admin"</span> password=<span class="string">"hello1234"</span> /&gt;</span><br><span class="line"> </span><br><span class="line">    &lt;!-- 多协议配置 --&gt;</span><br><span class="line">    &lt;dubbo:protocol name=<span class="string">"dubbo"</span> port=<span class="string">"20880"</span> /&gt;</span><br><span class="line">    &lt;dubbo:protocol name=<span class="string">"rmi"</span> port=<span class="string">"1099"</span> /&gt;</span><br><span class="line"> </span><br><span class="line">    &lt;!-- 使用dubbo协议暴露服务 --&gt;</span><br><span class="line">    &lt;dubbo:service <span class="class"><span class="keyword">interface</span></span>=<span class="string">"com.alibaba.hello.api.HelloService"</span> version=<span class="string">"1.0.0"</span> ref=<span class="string">"helloService"</span> protocol=<span class="string">"dubbo"</span> /&gt;</span><br><span class="line">    &lt;!-- 使用rmi协议暴露服务 --&gt;</span><br><span class="line">    &lt;dubbo:service <span class="class"><span class="keyword">interface</span></span>=<span class="string">"com.alibaba.hello.api.DemoService"</span> version=<span class="string">"1.0.0"</span> ref=<span class="string">"demoService"</span> protocol=<span class="string">"rmi"</span> /&gt;</span><br><span class="line"> </span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>
<p>(2) 多协议暴露服务</p>
<p>consumer.xml</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;</span><br><span class="line">&lt;beans xmlns=<span class="string">"http://www.springframework.org/schema/beans"</span></span><br><span class="line">    xmlns:xsi=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="line">    xmlns:dubbo=<span class="string">"http://code.alibabatech.com/schema/dubbo"</span></span><br><span class="line">    xsi:schemaLocation=<span class="string">"http://www.springframework.org/schema/beans</span></span><br><span class="line"><span class="string">http://www.springframework.org/schema/beans/spring-beans.xsd</span></span><br><span class="line"><span class="string">http://code.alibabatech.com/schema/dubbohttp://code.alibabatech.com/schema/dubbo/dubbo.xsd"</span>&gt;</span><br><span class="line">&lt;dubbo:application name=<span class="string">"world"</span>  /&gt;</span><br><span class="line">    &lt;dubbo:registry id=<span class="string">"registry"</span> address=<span class="string">"10.20.141.150:9090"</span> username=<span class="string">"admin"</span> password=<span class="string">"hello1234"</span> /&gt;</span><br><span class="line"> </span><br><span class="line">    &lt;!-- 多协议配置 --&gt;</span><br><span class="line">    &lt;dubbo:protocol name=<span class="string">"dubbo"</span> port=<span class="string">"20880"</span> /&gt;</span><br><span class="line">    &lt;dubbo:protocol name=<span class="string">"hessian"</span> port=<span class="string">"8080"</span> /&gt;</span><br><span class="line"> </span><br><span class="line">    &lt;!-- 使用多个协议暴露服务 --&gt;</span><br><span class="line">    &lt;dubbo:service id=<span class="string">"helloService"</span> <span class="class"><span class="keyword">interface</span></span>=<span class="string">"com.alibaba.hello.api.HelloService"</span> </span><br><span class="line">version=<span class="string">"1.0.0"</span> protocol=<span class="string">"dubbo,hessian"</span> /&gt;</span><br><span class="line"> </span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>
<h4 id="多注册中心"><a href="#多注册中心" class="headerlink" title="多注册中心"></a>多注册中心</h4><p>(1) 多注册中心注册</p>
<p>比如：中文站有些服务来不及在青岛部署，只在杭州部署，而青岛的其它应用需要引用此服务，就可以将服务同时注册到两个注册中心。</p>
<p>consumer.xml</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;</span><br><span class="line">&lt;beans xmlns=<span class="string">"http://www.springframework.org/schema/beans"</span></span><br><span class="line">    xmlns:xsi=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="line">    xmlns:dubbo=<span class="string">"http://code.alibabatech.com/schema/dubbo"</span></span><br><span class="line">    xsi:schemaLocation=<span class="string">"http://www.springframework.org/schema/beans</span></span><br><span class="line"><span class="string">http://www.springframework.org/schema/beans/spring-beans.xsd</span></span><br><span class="line"><span class="string">http://code.alibabatech.com/schema/dubbohttp://code.alibabatech.com/schema/dubbo/dubbo.xsd"</span>&gt;</span><br><span class="line">&lt;dubbo:application name=<span class="string">"world"</span>  /&gt;</span><br><span class="line"> </span><br><span class="line">    &lt;!-- 多注册中心配置 --&gt;</span><br><span class="line">    &lt;dubbo:registry id=<span class="string">"hangzhouRegistry"</span> address=<span class="string">"10.20.141.150:9090"</span> /&gt;</span><br><span class="line">    &lt;dubbo:registry id=<span class="string">"qingdaoRegistry"</span> address=<span class="string">"10.20.141.151:9010"</span> <span class="keyword">default</span>=<span class="string">"false"</span> /&gt;</span><br><span class="line"> </span><br><span class="line">    &lt;!-- 向多个注册中心注册 --&gt;</span><br><span class="line">    &lt;dubbo:service <span class="class"><span class="keyword">interface</span></span>=<span class="string">"com.alibaba.hello.api.HelloService"</span> </span><br><span class="line">version=<span class="string">"1.0.0"</span> ref=<span class="string">"helloService"</span> registry=<span class="string">"hangzhouRegistry,qingdaoRegistry"</span> /&gt;</span><br><span class="line"> </span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>
<p>(2) 不同服务使用不同注册中心</p>
<p>比如：CRM有些服务是专门为国际站设计的，有些服务是专门为中文站设计的。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;</span><br><span class="line">&lt;beans xmlns=<span class="string">"http://www.springframework.org/schema/beans"</span></span><br><span class="line">    xmlns:xsi=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="line">    xmlns:dubbo=<span class="string">"http://code.alibabatech.com/schema/dubbo"</span></span><br><span class="line">    xsi:schemaLocation=<span class="string">"http://www.springframework.org/schema/beans</span></span><br><span class="line"><span class="string">http://www.springframework.org/schema/beans/spring-beans.xsd</span></span><br><span class="line"><span class="string">http://code.alibabatech.com/schema/dubbohttp://code.alibabatech.com/schema/dubbo/dubbo.xsd"</span>&gt;</span><br><span class="line"> &lt;dubbo:application name=<span class="string">"world"</span>  /&gt;</span><br><span class="line"> </span><br><span class="line">    &lt;!-- 多注册中心配置 --&gt;</span><br><span class="line">    &lt;dubbo:registry id=<span class="string">"chinaRegistry"</span> address=<span class="string">"10.20.141.150:9090"</span> /&gt;</span><br><span class="line">    &lt;dubbo:registry id=<span class="string">"intlRegistry"</span> address=<span class="string">"10.20.154.177:9010"</span> <span class="keyword">default</span>=<span class="string">"false"</span> /&gt;</span><br><span class="line"> </span><br><span class="line">    &lt;!-- 向中文站注册中心注册 --&gt;</span><br><span class="line">    &lt;dubbo:service <span class="class"><span class="keyword">interface</span></span>=<span class="string">"com.alibaba.hello.api.HelloService"</span> version=<span class="string">"1.0.0"</span> ref=<span class="string">"helloService"</span> registry=<span class="string">"chinaRegistry"</span> /&gt;</span><br><span class="line"> </span><br><span class="line">    &lt;!-- 向国际站注册中心注册 --&gt;</span><br><span class="line">    &lt;dubbo:service <span class="class"><span class="keyword">interface</span></span>=<span class="string">"com.alibaba.hello.api.DemoService"</span> version=<span class="string">"1.0.0"</span> ref=<span class="string">"demoService"</span> registry=<span class="string">"intlRegistry"</span> /&gt;</span><br><span class="line"> </span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>
<p>(3) 多注册中心引用</p>
<p>比如：CRM需同时调用中文站和国际站的PC2服务，PC2在中文站和国际站均有部署，接口及版本号都一样，但连的数据库不一样。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;</span><br><span class="line">&lt;beans xmlns=<span class="string">"http://www.springframework.org/schema/beans"</span></span><br><span class="line">    xmlns:xsi=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="line">    xmlns:dubbo=<span class="string">"http://code.alibabatech.com/schema/dubbo"</span></span><br><span class="line">    xsi:schemaLocation=<span class="string">"http://www.springframework.org/schema/beans</span></span><br><span class="line"><span class="string">http://www.springframework.org/schema/beans/spring-beans.xsdhttp://code.alibabatech.com/schema/dubbo</span></span><br><span class="line"><span class="string">http://code.alibabatech.com/schema/dubbo/dubbo.xsd"</span>&gt;</span><br><span class="line">&lt;dubbo:application name=<span class="string">"world"</span>  /&gt;</span><br><span class="line"> </span><br><span class="line">    &lt;!-- 多注册中心配置 --&gt;</span><br><span class="line">    &lt;dubbo:registry id=<span class="string">"chinaRegistry"</span> address=<span class="string">"10.20.141.150:9090"</span> /&gt;</span><br><span class="line">    &lt;dubbo:registry id=<span class="string">"intlRegistry"</span> address=<span class="string">"10.20.154.177:9010"</span> <span class="keyword">default</span>=<span class="string">"false"</span> /&gt;</span><br><span class="line"> </span><br><span class="line">    &lt;!-- 引用中文站服务 --&gt;</span><br><span class="line">    &lt;dubbo:reference id=<span class="string">"chinaHelloService"</span> </span><br><span class="line"><span class="class"><span class="keyword">interface</span></span>=<span class="string">"com.alibaba.hello.api.HelloService"</span> version=<span class="string">"1.0.0"</span> registry=<span class="string">"chinaRegistry"</span> /&gt;</span><br><span class="line"> </span><br><span class="line">    &lt;!-- 引用国际站站服务 --&gt;</span><br><span class="line">    &lt;dubbo:reference id=<span class="string">"intlHelloService"</span> </span><br><span class="line"><span class="class"><span class="keyword">interface</span></span>=<span class="string">"com.alibaba.hello.api.HelloService"</span> version=<span class="string">"1.0.0"</span> registry=<span class="string">"intlRegistry"</span> /&gt;</span><br><span class="line"> </span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>
<p>如果只是测试环境临时需要连接两个不同注册中心，使用竖号分隔多个不同注册中心地址：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;</span><br><span class="line">&lt;beans xmlns=<span class="string">"http://www.springframework.org/schema/beans"</span></span><br><span class="line">    xmlns:xsi=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="line">    xmlns:dubbo=<span class="string">"http://code.alibabatech.com/schema/dubbo"</span></span><br><span class="line">    xsi:schemaLocation=<span class="string">"http://www.springframework.org/schema/beans</span></span><br><span class="line"><span class="string">http://www.springframework.org/schema/beans/spring-beans.xsd</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">http://code.alibabatech.com/schema/dubbohttp://code.alibabatech.com/schema/dubbo/dubbo.xsd"</span>&gt;</span><br><span class="line"> </span><br><span class="line">    &lt;dubbo:application name=<span class="string">"world"</span>  /&gt;</span><br><span class="line"> </span><br><span class="line">    &lt;!-- 多注册中心配置，竖号分隔表示同时连接多个不同注册中心，</span><br><span class="line">同一注册中心的多个集群地址用逗号分隔 --&gt;</span><br><span class="line">    &lt;dubbo:registry address=<span class="string">"10.20.141.150:9090|10.20.154.177:9010"</span> /&gt;</span><br><span class="line"> </span><br><span class="line">    &lt;!-- 引用服务 --&gt;</span><br><span class="line">    &lt;dubbo:reference id=<span class="string">"helloService"</span> <span class="class"><span class="keyword">interface</span></span>=<span class="string">"com.alibaba.hello.api.HelloService"</span> version=<span class="string">"1.0.0"</span> /&gt;</span><br><span class="line"> </span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>
<h4 id="服务分组"><a href="#服务分组" class="headerlink" title="服务分组"></a>服务分组</h4><p>当一个接口有多种实现时，可以用group区分。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;dubbo:service</span><br><span class="line">group=<span class="string">"feedback"</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span></span>=<span class="string">"com.xxx.IndexService"</span></span><br><span class="line">/&gt;</span><br><span class="line"></span><br><span class="line">&lt;dubbo:service</span><br><span class="line">group=<span class="string">"member"</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span></span>=<span class="string">"com.xxx.IndexService"</span></span><br><span class="line">/&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;dubbo:reference</span><br><span class="line">id=<span class="string">"feedbackIndexService"</span></span><br><span class="line">group=<span class="string">"feedback"</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span></span>=<span class="string">"com.xxx.IndexService"</span></span><br><span class="line">/&gt;</span><br><span class="line"></span><br><span class="line">&lt;dubbo:reference</span><br><span class="line">id=<span class="string">"memberIndexService"</span></span><br><span class="line">group=<span class="string">"member"</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span></span>=<span class="string">"com.xxx.IndexService"</span></span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure>
<h4 id="多版本"><a href="#多版本" class="headerlink" title="多版本"></a>多版本</h4><p>当一个接口实现，出现不兼容升级时，可以用版本号过渡，版本号不同的服务相互间不引用。</p>
<p>在低压力时间段，先升级一半提供者为新版本<br>再将所有消费者升级为新版本<br>然后将剩下的一半提供者升级为新版本</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&lt;dubbo:service</span><br><span class="line"><span class="class"><span class="keyword">interface</span></span>=<span class="string">"com.foo.BarService"</span></span><br><span class="line">version=<span class="string">"1.0.0"</span></span><br><span class="line">/&gt;</span><br><span class="line"></span><br><span class="line">&lt;dubbo:service</span><br><span class="line"><span class="class"><span class="keyword">interface</span></span>=<span class="string">"com.foo.BarService"</span></span><br><span class="line">version=<span class="string">"2.0.0"</span></span><br><span class="line">/&gt;</span><br><span class="line"></span><br><span class="line">&lt;dubbo:reference</span><br><span class="line">id=<span class="string">"barService"</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span></span>=<span class="string">"com.foo.BarService"</span></span><br><span class="line">version=<span class="string">"1.0.0"</span></span><br><span class="line">/&gt;</span><br><span class="line"></span><br><span class="line">&lt;dubbo:reference</span><br><span class="line">id=<span class="string">"barService"</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span></span>=<span class="string">"com.foo.BarService"</span></span><br><span class="line">version=<span class="string">"2.0.0"</span></span><br><span class="line">/&gt;</span><br><span class="line"></span><br><span class="line">不区分版本</span><br><span class="line">&lt;dubbo:reference</span><br><span class="line">id=<span class="string">"barService"</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span></span>=<span class="string">"com.foo.BarService"</span></span><br><span class="line">version=<span class="string">"*"</span></span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure>
<h4 id="分组聚合"><a href="#分组聚合" class="headerlink" title="分组聚合"></a>分组聚合</h4><p>按组合并返回结果，比如菜单服务，接口一样，但有多种实现，用group区分，现在消费方需从每种group中调用一次返回结果，合并结果返回，这样就可以实现聚合菜单项。</p>
<p>从2.1.0版本开始支持</p>
<p><img src="http://www.uml.org.cn/zjjs/images/2015091045.jpg" alt="cmd-markdown-logo"></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">搜索所有分组：</span><br><span class="line">&lt;dubbo:reference</span><br><span class="line"><span class="class"><span class="keyword">interface</span></span>=<span class="string">"com.xxx.MenuService"</span></span><br><span class="line">group=<span class="string">"*"</span></span><br><span class="line">merger=<span class="string">"true"</span></span><br><span class="line">/&gt;</span><br><span class="line"></span><br><span class="line">合并指定分组：</span><br><span class="line">&lt;dubbo:reference</span><br><span class="line"><span class="class"><span class="keyword">interface</span></span>=<span class="string">"com.xxx.MenuService"</span></span><br><span class="line">group=<span class="string">"aaa,bbb"</span></span><br><span class="line">merger=<span class="string">"true"</span></span><br><span class="line">/&gt;</span><br><span class="line"></span><br><span class="line">指定方法合并结果，其它未指定的方法，将只调用一个Group：</span><br><span class="line">&lt;dubbo:reference</span><br><span class="line"><span class="class"><span class="keyword">interface</span></span>=<span class="string">"com.xxx.MenuService"</span></span><br><span class="line">group=<span class="string">"*"</span>&gt;</span><br><span class="line">	&lt;dubbo:method</span><br><span class="line">	name=<span class="string">"getMenuItems"</span></span><br><span class="line">	merger=<span class="string">"true"</span></span><br><span class="line">	/&gt;</span><br><span class="line">&lt;/dubbo:service&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">某个方法不合并结果，其它都合并结果：</span><br><span class="line">&lt;dubbo:reference</span><br><span class="line"><span class="class"><span class="keyword">interface</span></span>=<span class="string">"com.xxx.MenuService"</span></span><br><span class="line">group=<span class="string">"*"</span></span><br><span class="line">merger=<span class="string">"true"</span>&gt;</span><br><span class="line">	&lt;dubbo:method</span><br><span class="line">	name=<span class="string">"getMenuItems"</span></span><br><span class="line">	merger=<span class="string">"false"</span></span><br><span class="line">	/&gt;</span><br><span class="line">&lt;/dubbo:service&gt;</span><br></pre></td></tr></table></figure>
<h4 id="参数验证"><a href="#参数验证" class="headerlink" title="参数验证"></a>参数验证</h4><p>参数验证功能是基于JSR303实现的，用户只需标识JSR303标准的验证Annotation，并通过声明filter来实现验证。</p>
<p>2.1.0以上版本支持</p>
<p>完整示例代码参见：<a href="https://github.com/alibaba/dubbo/tree/master/dubbo-test/dubbo-test-examples/src/main/java/com/alibaba/dubbo/examples/validation" target="_blank" rel="noopener">https://github.com/alibaba/dubbo/tree/master/dubbo-test/dubbo-test-examples/src/main/java/com/alibaba/dubbo/examples/validation</a></p>
<p>验证方式可扩展，参见：Validation扩展点</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://killgc.github.io/shortfeng/shortfeng/2018/03/22/ConcurrentHashMap/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="changfeng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/shortfeng/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/shortfeng/2018/03/22/ConcurrentHashMap/" itemprop="url">ConcurrentHashMap</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-22T22:56:26+08:00">
                2018-03-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h2><hr>
<p>HashMap为非线程安全的，多线程并发下put操作有可能引起死循环，而HashTable、Collections.synchronizedMap(hashMap)是线程安全的。</p>
<h4 id="JDK6实现"><a href="#JDK6实现" class="headerlink" title="JDK6实现"></a>JDK6实现</h4><hr>
<p>使用锁分段实现多个线程间并发写操作，采用数组+链表结构的存储结构</p>
<blockquote>
<ul>
<li>包含两个静态内部类Segment和HashEntry</li>
<li>Segment继承ReentrantLock，用来充当锁的角色，每个Segment对象守护一个散列映射表的若干桶，每个段实质是一个小的HashMap</li>
<li>每个桶是由若干个HashEntry对象链接起来的链表</li>
<li>不允许null作为映射值</li>
</ul>
</blockquote>
<p>定位：</p>
<p>假设ConcurrentHashMap一共分为2^n个段，每个段中有2^m个桶，那么段的定位方式是将key的hash值的高n位与(2^n-1)相与。在定位到某个段后，再将key的hash值的低m位与(2^m-1)相与，定位到具体的桶位</p>
<p>内部结构：<br><img src="https://www.ibm.com/developerworks/cn/java/java-lo-concurrenthashmap/image005.jpg" alt="cmd-markdown-logo"></p>
<p>1、HashEntry</p>
<blockquote>
<ul>
<li>HashEntry的next属性为final，所有新节点只能在链表的表头插入</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HashEntry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123; </span><br><span class="line">       <span class="keyword">final</span> K key;                       <span class="comment">// 声明 key 为 final 型</span></span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">int</span> hash;                   <span class="comment">// 声明 hash 值为 final 型 </span></span><br><span class="line">       <span class="keyword">volatile</span> V value;                 <span class="comment">// 声明 value 为 volatile 型</span></span><br><span class="line">       <span class="keyword">final</span> HashEntry&lt;K,V&gt; next;      <span class="comment">// 声明 next 为 final 型 </span></span><br><span class="line"> </span><br><span class="line">       HashEntry(K key, <span class="keyword">int</span> hash, HashEntry&lt;K,V&gt; next, V value) &#123; </span><br><span class="line">           <span class="keyword">this</span>.key = key; </span><br><span class="line">           <span class="keyword">this</span>.hash = hash; </span><br><span class="line">           <span class="keyword">this</span>.next = next; </span><br><span class="line">           <span class="keyword">this</span>.value = value; </span><br><span class="line">       &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2、Segment</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Segment</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">ReentrantLock</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123; </span><br><span class="line">       <span class="comment">/** </span></span><br><span class="line"><span class="comment">        * 在本 segment 范围内，包含的 HashEntry 元素的个数</span></span><br><span class="line"><span class="comment">        * 该变量被声明为 volatile 型</span></span><br><span class="line"><span class="comment">        */</span> </span><br><span class="line">       <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> count; </span><br><span class="line"> </span><br><span class="line">       <span class="comment">/** </span></span><br><span class="line"><span class="comment">        * table 被更新的次数</span></span><br><span class="line"><span class="comment">        */</span> </span><br><span class="line">       <span class="keyword">transient</span> <span class="keyword">int</span> modCount; </span><br><span class="line"> </span><br><span class="line">       <span class="comment">/** </span></span><br><span class="line"><span class="comment">        * 当 table 中包含的 HashEntry 元素的个数超过本变量值时，触发 table 的再散列</span></span><br><span class="line"><span class="comment">        */</span> </span><br><span class="line">       <span class="keyword">transient</span> <span class="keyword">int</span> threshold; </span><br><span class="line"> </span><br><span class="line">       <span class="comment">/** </span></span><br><span class="line"><span class="comment">        * table 是由 HashEntry 对象组成的数组</span></span><br><span class="line"><span class="comment">        * 如果散列时发生碰撞，碰撞的 HashEntry 对象就以链表的形式链接成一个链表</span></span><br><span class="line"><span class="comment">        * table 数组的数组成员代表散列映射表的一个桶</span></span><br><span class="line"><span class="comment">        * 每个 table 守护整个 ConcurrentHashMap 包含桶总数的一部分</span></span><br><span class="line"><span class="comment">        * 如果并发级别为 16，table 则守护 ConcurrentHashMap 包含的桶总数的 1/16 </span></span><br><span class="line"><span class="comment">        */</span> </span><br><span class="line">       <span class="keyword">transient</span> <span class="keyword">volatile</span> HashEntry&lt;K,V&gt;[] table; </span><br><span class="line"> </span><br><span class="line">       <span class="comment">/** </span></span><br><span class="line"><span class="comment">        * 装载因子</span></span><br><span class="line"><span class="comment">        */</span> </span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">float</span> loadFactor; </span><br><span class="line"> </span><br><span class="line">       Segment(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> lf) &#123; </span><br><span class="line">           loadFactor = lf; </span><br><span class="line">           setTable(HashEntry.&lt;K,V&gt;newArray(initialCapacity)); </span><br><span class="line">       &#125; </span><br><span class="line"> </span><br><span class="line">       <span class="comment">/** </span></span><br><span class="line"><span class="comment">        * 设置 table 引用到这个新生成的 HashEntry 数组</span></span><br><span class="line"><span class="comment">        * 只能在持有锁或构造函数中调用本方法</span></span><br><span class="line"><span class="comment">        */</span> </span><br><span class="line">       <span class="function"><span class="keyword">void</span> <span class="title">setTable</span><span class="params">(HashEntry&lt;K,V&gt;[] newTable)</span> </span>&#123; </span><br><span class="line">           <span class="comment">// 计算临界阀值为新数组的长度与装载因子的乘积</span></span><br><span class="line">           threshold = (<span class="keyword">int</span>)(newTable.length * loadFactor); </span><br><span class="line">           table = newTable; </span><br><span class="line">       &#125; </span><br><span class="line"> </span><br><span class="line">       <span class="comment">/** </span></span><br><span class="line"><span class="comment">        * 根据 key 的散列值，找到 table 中对应的那个桶（table 数组的某个数组成员）</span></span><br><span class="line"><span class="comment">        */</span> </span><br><span class="line">       <span class="function">HashEntry&lt;K,V&gt; <span class="title">getFirst</span><span class="params">(<span class="keyword">int</span> hash)</span> </span>&#123; </span><br><span class="line">           HashEntry&lt;K,V&gt;[] tab = table; </span><br><span class="line">           <span class="comment">// 把散列值与 table 数组长度减 1 的值相“与”，</span></span><br><span class="line"><span class="comment">// 得到散列值对应的 table 数组的下标</span></span><br><span class="line">           <span class="comment">// 然后返回 table 数组中此下标对应的 HashEntry 元素</span></span><br><span class="line">           <span class="keyword">return</span> tab[hash &amp; (tab.length - <span class="number">1</span>)]; </span><br><span class="line">       &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3、ConcurrentHashMap</p>
<blockquote>
<ul>
<li>默认并发数为16</li>
<li>映射表的默认初始容量为16,即16个桶</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcurrentHashMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span></span><br><span class="line"><span class="class">       <span class="keyword">implements</span> <span class="title">ConcurrentMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt;, <span class="title">Serializable</span> </span>&#123; </span><br><span class="line"> </span><br><span class="line">   <span class="comment">/** </span></span><br><span class="line"><span class="comment">    * 散列映射表的默认初始容量为 16，即初始默认为 16 个桶</span></span><br><span class="line"><span class="comment">    * 在构造函数中没有指定这个参数时，使用本参数</span></span><br><span class="line"><span class="comment">    */</span> </span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span>     <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY= <span class="number">16</span>; </span><br><span class="line"> </span><br><span class="line">   <span class="comment">/** </span></span><br><span class="line"><span class="comment">    * 散列映射表的默认装载因子为 0.75，该值是 table 中包含的 HashEntry 元素的个数与</span></span><br><span class="line"><span class="comment">* table 数组长度的比值</span></span><br><span class="line"><span class="comment">    * 当 table 中包含的 HashEntry 元素的个数超过了 table 数组的长度与装载因子的乘积时，</span></span><br><span class="line"><span class="comment">* 将触发 再散列</span></span><br><span class="line"><span class="comment">    * 在构造函数中没有指定这个参数时，使用本参数</span></span><br><span class="line"><span class="comment">    */</span> </span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR= <span class="number">0.75f</span>; </span><br><span class="line"> </span><br><span class="line">   <span class="comment">/** </span></span><br><span class="line"><span class="comment">    * 散列表的默认并发级别为 16。该值表示当前更新线程的估计数</span></span><br><span class="line"><span class="comment">    * 在构造函数中没有指定这个参数时，使用本参数</span></span><br><span class="line"><span class="comment">    */</span> </span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CONCURRENCY_LEVEL= <span class="number">16</span>; </span><br><span class="line"> </span><br><span class="line">   <span class="comment">/** </span></span><br><span class="line"><span class="comment">    * segments 的掩码值</span></span><br><span class="line"><span class="comment">    * key 的散列码的高位用来选择具体的 segment </span></span><br><span class="line"><span class="comment">    */</span> </span><br><span class="line">   <span class="keyword">final</span> <span class="keyword">int</span> segmentMask; </span><br><span class="line"> </span><br><span class="line">   <span class="comment">/** </span></span><br><span class="line"><span class="comment">    * 偏移量</span></span><br><span class="line"><span class="comment">    */</span> </span><br><span class="line">   <span class="keyword">final</span> <span class="keyword">int</span> segmentShift; </span><br><span class="line"> </span><br><span class="line">   <span class="comment">/** </span></span><br><span class="line"><span class="comment">    * 由 Segment 对象组成的数组</span></span><br><span class="line"><span class="comment">    */</span> </span><br><span class="line">   <span class="keyword">final</span> Segment&lt;K,V&gt;[] segments; </span><br><span class="line"> </span><br><span class="line">   <span class="comment">/** </span></span><br><span class="line"><span class="comment">    * 创建一个带有指定初始容量、加载因子和并发级别的新的空映射。</span></span><br><span class="line"><span class="comment">    */</span> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, </span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">float</span> loadFactor, <span class="keyword">int</span> concurrencyLevel)</span> </span>&#123; </span><br><span class="line">       <span class="keyword">if</span>(!(loadFactor &gt; <span class="number">0</span>) || initialCapacity &lt; <span class="number">0</span> || </span><br><span class="line">concurrencyLevel &lt;= <span class="number">0</span>) </span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(); </span><br><span class="line"> </span><br><span class="line">       <span class="keyword">if</span>(concurrencyLevel &gt; MAX_SEGMENTS) </span><br><span class="line">           concurrencyLevel = MAX_SEGMENTS; </span><br><span class="line"> </span><br><span class="line">       <span class="comment">// 寻找最佳匹配参数（不小于给定参数的最接近的 2 次幂） </span></span><br><span class="line">       <span class="keyword">int</span> sshift = <span class="number">0</span>; </span><br><span class="line">       <span class="keyword">int</span> ssize = <span class="number">1</span>; </span><br><span class="line">       <span class="keyword">while</span>(ssize &lt; concurrencyLevel) &#123; </span><br><span class="line">           ++sshift; </span><br><span class="line">           ssize &lt;&lt;= <span class="number">1</span>; </span><br><span class="line">       &#125; </span><br><span class="line">       segmentShift = <span class="number">32</span> - sshift;       <span class="comment">// 偏移量值</span></span><br><span class="line">       segmentMask = ssize - <span class="number">1</span>;           <span class="comment">// 掩码值 </span></span><br><span class="line">       <span class="keyword">this</span>.segments = Segment.newArray(ssize);   <span class="comment">// 创建数组</span></span><br><span class="line"> </span><br><span class="line">       <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY) </span><br><span class="line">           initialCapacity = MAXIMUM_CAPACITY; </span><br><span class="line">       <span class="keyword">int</span> c = initialCapacity / ssize; </span><br><span class="line">       <span class="keyword">if</span>(c * ssize &lt; initialCapacity) </span><br><span class="line">           ++c; </span><br><span class="line">       <span class="keyword">int</span> cap = <span class="number">1</span>; </span><br><span class="line">       <span class="keyword">while</span>(cap &lt; c) </span><br><span class="line">           cap &lt;&lt;= <span class="number">1</span>; </span><br><span class="line"> </span><br><span class="line">       <span class="comment">// 依次遍历每个数组元素</span></span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.segments.length; ++i) </span><br><span class="line">           <span class="comment">// 初始化每个数组元素引用的 Segment 对象</span></span><br><span class="line"><span class="keyword">this</span>.segments[i] = <span class="keyword">new</span> Segment&lt;K,V&gt;(cap, loadFactor); </span><br><span class="line">   &#125; </span><br><span class="line"> </span><br><span class="line">   <span class="comment">/** </span></span><br><span class="line"><span class="comment">    * 创建一个带有默认初始容量 (16)、默认加载因子 (0.75) 和 默认并发级别 (16) </span></span><br><span class="line"><span class="comment"> * 的空散列映射表。</span></span><br><span class="line"><span class="comment">    */</span> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">()</span> </span>&#123; </span><br><span class="line">       <span class="comment">// 使用三个默认参数，调用上面重载的构造函数来创建空散列映射表</span></span><br><span class="line"><span class="keyword">this</span>(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR, DEFAULT_CONCURRENCY_LEVEL); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="put方法"><a href="#put方法" class="headerlink" title="put方法"></a>put方法</h4><p>ConcurrentHashMap:</p>
<p>根据 key 计算出对应的 hash 值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123; </span><br><span class="line">       <span class="keyword">if</span> (value == <span class="keyword">null</span>)          <span class="comment">//ConcurrentHashMap 中不允许用 null 作为映射值</span></span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(); </span><br><span class="line">       <span class="keyword">int</span> hash = hash(key.hashCode());        <span class="comment">// 计算键对应的散列码</span></span><br><span class="line">       <span class="comment">// 根据散列码找到对应的 Segment </span></span><br><span class="line">       <span class="keyword">return</span> segmentFor(hash).put(key, hash, value, <span class="keyword">false</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据 hash 值找到对应的 Segment</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">    * 使用 key 的散列码来得到 segments 数组中对应的 Segment </span></span><br><span class="line"><span class="comment">    */</span> </span><br><span class="line"><span class="function"><span class="keyword">final</span> Segment&lt;K,V&gt; <span class="title">segmentFor</span><span class="params">(<span class="keyword">int</span> hash)</span> </span>&#123; </span><br><span class="line">   <span class="comment">// 将散列值右移 segmentShift 个位，并在高位填充 0 </span></span><br><span class="line">   <span class="comment">// 然后把得到的值与 segmentMask 相“与”</span></span><br><span class="line"><span class="comment">// 从而得到 hash 值对应的 segments 数组的下标值</span></span><br><span class="line"><span class="comment">// 最后根据下标值返回散列码对应的 Segment 对象</span></span><br><span class="line">       <span class="keyword">return</span> segments[(hash &gt;&gt;&gt; segmentShift) &amp; segmentMask]; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Segment:</p>
<p>在 Segment 中执行具体的 put 操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">V <span class="title">put</span><span class="params">(K key, <span class="keyword">int</span> hash, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123; </span><br><span class="line">           lock();  <span class="comment">// 加锁，这里是锁定某个 Segment 对象而非整个 ConcurrentHashMap </span></span><br><span class="line">           <span class="keyword">try</span> &#123; </span><br><span class="line">               <span class="keyword">int</span> c = count; </span><br><span class="line"> </span><br><span class="line">               <span class="keyword">if</span> (c++ &gt; threshold)     <span class="comment">// 如果超过再散列的阈值</span></span><br><span class="line">                   rehash();              <span class="comment">// 执行再散列，table 数组的长度将扩充一倍</span></span><br><span class="line"> </span><br><span class="line">               HashEntry&lt;K,V&gt;[] tab = table; </span><br><span class="line">               <span class="comment">// 把散列码值与 table 数组的长度减 1 的值相“与”</span></span><br><span class="line">               <span class="comment">// 得到该散列码对应的 table 数组的下标值</span></span><br><span class="line">               <span class="keyword">int</span> index = hash &amp; (tab.length - <span class="number">1</span>); </span><br><span class="line">               <span class="comment">// 找到散列码对应的具体的那个桶</span></span><br><span class="line">               HashEntry&lt;K,V&gt; first = tab[index]; </span><br><span class="line"> </span><br><span class="line">               HashEntry&lt;K,V&gt; e = first; </span><br><span class="line">               <span class="keyword">while</span> (e != <span class="keyword">null</span> &amp;&amp; (e.hash != hash || !key.equals(e.key))) </span><br><span class="line">                   e = e.next; </span><br><span class="line"> </span><br><span class="line">               V oldValue; </span><br><span class="line">               <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;            <span class="comment">// 如果键 / 值对以经存在</span></span><br><span class="line">                   oldValue = e.value; </span><br><span class="line">                   <span class="keyword">if</span> (!onlyIfAbsent) </span><br><span class="line">                       e.value = value;    <span class="comment">// 设置 value 值</span></span><br><span class="line">               &#125; </span><br><span class="line">               <span class="keyword">else</span> &#123;                        <span class="comment">// 键 / 值对不存在 </span></span><br><span class="line">                   oldValue = <span class="keyword">null</span>; </span><br><span class="line">                   ++modCount;         <span class="comment">// 要添加新节点到链表中，所以 modCont 要加 1  </span></span><br><span class="line">                   <span class="comment">// 创建新节点，并添加到链表的头部 </span></span><br><span class="line">                   tab[index] = <span class="keyword">new</span> HashEntry&lt;K,V&gt;(key, hash, first, value); </span><br><span class="line">                   count = c;               <span class="comment">// 写 count 变量</span></span><br><span class="line">               &#125; </span><br><span class="line">               <span class="keyword">return</span> oldValue; </span><br><span class="line">           &#125; <span class="keyword">finally</span> &#123; </span><br><span class="line">               unlock();                     <span class="comment">// 解锁</span></span><br><span class="line">           &#125; </span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>
<h5 id="HashEntry-对象的不变性来降低读操作对加锁的需求"><a href="#HashEntry-对象的不变性来降低读操作对加锁的需求" class="headerlink" title="HashEntry 对象的不变性来降低读操作对加锁的需求"></a>HashEntry 对象的不变性来降低读操作对加锁的需求</h5><blockquote>
<ul>
<li>HashEntry的next属性声明为final：不能把节点添加到链接的中间和尾部，也不能在链接的中间和尾部删除节点，访问某个节点时，这个节点之后链接不会被改变。</li>
<li>HashEntry的value属性声明为volatile，某个写线程对 value 属性的写入马上可以被后续的某个读线程“看”到；ConcurrentHashMap 中，不允许用 null 作为键和值，当读线程读到某个 HashEntry 的 value 属性的值为 null 时，便知道产生了冲突——发生了重排序现象，需要加锁后重新读入这个 value 值</li>
<li>对散列表做非结构性修改的操作：只是更改某个 HashEntry 的 value 域的值；写线程对链表的非结构性修改能够被后续不加锁的读线程“看到</li>
<li>对散列表做结构性修改：实质上是对某个桶指向的链表做结构性修改,如果能够确保：在读线程遍历一个链表期间，写线程对这个链表所做的结构性修改不影响读线程继续正常遍历这个链表。那么读 / 写线程之间就可以安全并发访问这个 ConcurrentHashMap</li>
<li>clear操作：只是把 ConcurrentHashMap 中所有的桶“置空”，每个桶之前引用的链表依然存在，只是桶不再引用到这些链表（所有链表的结构并没有被修改）。正在遍历某个链表的读线程依然可以正常执行对该链表的遍历</li>
<li>put操作：put 操作如果需要插入一个新节点到链表中时 , 会在链表头部插入这个新节点。此时，链表中的原有节点的链接并没有被修改。也就是说：插入新健 / 值对到链表中的操作不会影响读线程正常遍历这个链表</li>
<li>remove操作： 待删除节点之后的节点原样保留在链表中，待删除节点之前的节点被克隆到新链表，链表的新头节点为待删除节点之前的那个节点；在执行 remove 操作时，原始链表并没有被修改，也就是说：读线程不会受同时执行 remove 操作的并发写线程的干扰</li>
</ul>
</blockquote>
<p>删除C节点前：<br><img src="https://www.ibm.com/developerworks/cn/java/java-lo-concurrenthashmap/image007.jpg" alt="cmd-markdown-logo"></p>
<p>删除C节点后：<br><img src="https://www.ibm.com/developerworks/cn/java/java-lo-concurrenthashmap/image008.jpg" alt="cmd-markdown-logo"></p>
<p>Segment的remove方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">V <span class="title">remove</span><span class="params">(Object key, <span class="keyword">int</span> hash, Object value)</span> </span>&#123; </span><br><span class="line">           lock();         <span class="comment">// 加锁</span></span><br><span class="line">           <span class="keyword">try</span>&#123; </span><br><span class="line">               <span class="keyword">int</span> c = count - <span class="number">1</span>; </span><br><span class="line">               HashEntry&lt;K,V&gt;[] tab = table; </span><br><span class="line">               <span class="comment">// 根据散列码找到 table 的下标值</span></span><br><span class="line">               <span class="keyword">int</span> index = hash &amp; (tab.length - <span class="number">1</span>); </span><br><span class="line">               <span class="comment">// 找到散列码对应的那个桶</span></span><br><span class="line">               HashEntry&lt;K,V&gt; first = tab[index]; </span><br><span class="line">               HashEntry&lt;K,V&gt; e = first; </span><br><span class="line">               <span class="keyword">while</span>(e != <span class="keyword">null</span>&amp;&amp; (e.hash != hash || !key.equals(e.key))) </span><br><span class="line">                   e = e.next; </span><br><span class="line"> </span><br><span class="line">               V oldValue = <span class="keyword">null</span>; </span><br><span class="line">               <span class="keyword">if</span>(e != <span class="keyword">null</span>) &#123; </span><br><span class="line">                   V v = e.value; </span><br><span class="line">                   <span class="keyword">if</span>(value == <span class="keyword">null</span>|| value.equals(v)) &#123; <span class="comment">// 找到要删除的节点</span></span><br><span class="line">                       oldValue = v; </span><br><span class="line">                       ++modCount; </span><br><span class="line">                       <span class="comment">// 所有处于待删除节点之后的节点原样保留在链表中</span></span><br><span class="line">                       <span class="comment">// 所有处于待删除节点之前的节点被克隆到新链表中</span></span><br><span class="line">                       HashEntry&lt;K,V&gt; newFirst = e.next;<span class="comment">// 待删节点的后继结点</span></span><br><span class="line">                       <span class="keyword">for</span>(HashEntry&lt;K,V&gt; p = first; p != e; p = p.next) </span><br><span class="line">                           newFirst = <span class="keyword">new</span> HashEntry&lt;K,V&gt;(p.key, p.hash, </span><br><span class="line">                                                         newFirst, p.value); </span><br><span class="line">                       <span class="comment">// 把桶链接到新的头结点</span></span><br><span class="line">                       <span class="comment">// 新的头结点是原链表中，删除节点之前的那个节点</span></span><br><span class="line">                       tab[index] = newFirst; </span><br><span class="line">                       count = c;      <span class="comment">// 写 count 变量</span></span><br><span class="line">                   &#125; </span><br><span class="line">               &#125; </span><br><span class="line">               <span class="keyword">return</span> oldValue; </span><br><span class="line">           &#125; <span class="keyword">finally</span>&#123; </span><br><span class="line">               unlock();               <span class="comment">// 解锁</span></span><br><span class="line">           &#125; </span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>
<h5 id="Segment的volatile修饰的count属性"><a href="#Segment的volatile修饰的count属性" class="headerlink" title="Segment的volatile修饰的count属性"></a>Segment的volatile修饰的count属性</h5><p>用来统计Segment中HashEntry的个数</p>
<p>在 ConcurrentHashMap 中，所有执行写操作的方法（put, remove, clear），在对链表做结构性修改之后，在退出写方法前都会去写这个 count 变量。所有未加锁的读操作（get, contains, containsKey）在读方法中，都会首先去读取这个 count 变量</p>
<p>Segment中的get方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">V <span class="title">get</span><span class="params">(Object key, <span class="keyword">int</span> hash)</span> </span>&#123; </span><br><span class="line">           <span class="keyword">if</span>(count != <span class="number">0</span>) &#123;       <span class="comment">// 首先读 count 变量</span></span><br><span class="line">               HashEntry&lt;K,V&gt; e = getFirst(hash); </span><br><span class="line">               <span class="keyword">while</span>(e != <span class="keyword">null</span>) &#123; </span><br><span class="line">                   <span class="keyword">if</span>(e.hash == hash &amp;&amp; key.equals(e.key)) &#123; </span><br><span class="line">                       V v = e.value; </span><br><span class="line">                       <span class="keyword">if</span>(v != <span class="keyword">null</span>)            </span><br><span class="line">                           <span class="keyword">return</span> v; </span><br><span class="line">                       <span class="comment">// 如果读到 value 域为 null，说明发生了重排序，加锁后重新读取</span></span><br><span class="line">                       <span class="keyword">return</span> readValueUnderLock(e); </span><br><span class="line">                   &#125; </span><br><span class="line">                   e = e.next; </span><br><span class="line">               &#125; </span><br><span class="line">           &#125; </span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">null</span>; </span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="ConcurrentHashMap的size操作"><a href="#ConcurrentHashMap的size操作" class="headerlink" title="ConcurrentHashMap的size操作"></a>ConcurrentHashMap的size操作</h5><p>先尝试2次通过不锁住Segment的方式来统计各个Segment大小，如果统计的过程中，容器的count发生了变化，则再采用加锁的方式来统计所有Segment的大小</p>
<p>在put , remove和clean方法里操作元素前都会将变量modCount进行加1，那么在统计size前后比较modCount是否发生变化，从而得知容器的大小是否发生变化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the number of key-value mappings in this map.  If the</span></span><br><span class="line"><span class="comment">     * map contains more than &lt;tt&gt;Integer.MAX_VALUE&lt;/tt&gt; elements, returns</span></span><br><span class="line"><span class="comment">     * &lt;tt&gt;Integer.MAX_VALUE&lt;/tt&gt;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the number of key-value mappings in this map</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Segment&lt;K,V&gt;[] segments = <span class="keyword">this</span>.segments;</span><br><span class="line">        <span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> check = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] mc = <span class="keyword">new</span> <span class="keyword">int</span>[segments.length];</span><br><span class="line">        <span class="comment">// Try a few times to get accurate count. On failure due to</span></span><br><span class="line">        <span class="comment">// continuous async changes in table, resort to locking.</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; RETRIES_BEFORE_LOCK; ++k) &#123;</span><br><span class="line">            check = <span class="number">0</span>;</span><br><span class="line">            sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> mcsum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; segments.length; ++i) &#123;</span><br><span class="line">                sum += segments[i].count;   </span><br><span class="line">                mcsum += mc[i] = segments[i].modCount;  <span class="comment">// 在统计size时记录modCount</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (mcsum != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; segments.length; ++i) &#123;</span><br><span class="line">                    check += segments[i].count;</span><br><span class="line">                    <span class="keyword">if</span> (mc[i] != segments[i].modCount) &#123;  <span class="comment">// 统计size后比较各段的modCount是否发生变化</span></span><br><span class="line">                        check = -<span class="number">1</span>; <span class="comment">// force retry</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (check == sum)<span class="comment">// 如果统计size前后各段的modCount没变，且两次得到的总数一致，直接返回</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (check != sum) &#123; <span class="comment">// Resort to locking all segments  // 加锁统计</span></span><br><span class="line">            sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; segments.length; ++i)</span><br><span class="line">                segments[i].lock();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; segments.length; ++i)</span><br><span class="line">                sum += segments[i].count;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; segments.length; ++i)</span><br><span class="line">                segments[i].unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sum &gt; Integer.MAX_VALUE)</span><br><span class="line">            <span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">int</span>)sum;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h5 id="ConcurrentHashMap的重哈希操作"><a href="#ConcurrentHashMap的重哈希操作" class="headerlink" title="ConcurrentHashMap的重哈希操作"></a>ConcurrentHashMap的重哈希操作</h5><p>ConcurrentHashMap的重哈希实际上是对ConcurrentHashMap的某个段的重哈希，因此ConcurrentHashMap的每个段所包含的桶位自然也就不尽相同</p>
<p>由于扩容是按照2的幂次方进行的，所以扩展前在同一个桶中的元素，现在要么还是在原来的序号的桶里，或者就是原来的序号再加上一个2的幂次方，就这两种选择</p>
<h4 id="JDK8实现"><a href="#JDK8实现" class="headerlink" title="JDK8实现"></a>JDK8实现</h4><hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://killgc.github.io/shortfeng/shortfeng/2018/03/21/HashMap/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="changfeng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/shortfeng/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/shortfeng/2018/03/21/HashMap/" itemprop="url">HashMap</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-21T12:57:47+08:00">
                2018-03-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><hr>
<p>特点：</p>
<blockquote>
<ul>
<li>允许null键/值</li>
<li>非同步</li>
<li>不保证有序（比如插入顺序）</li>
<li>不保证顺序不随时间变化</li>
</ul>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://killgc.github.io/shortfeng/shortfeng/2018/03/19/JVM/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="changfeng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/shortfeng/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/shortfeng/2018/03/19/JVM/" itemprop="url">JVM</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-19T22:22:30+08:00">
                2018-03-19
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="内存区域"><a href="#内存区域" class="headerlink" title="内存区域"></a>内存区域</h4><hr>
<p>Java内存粗糙的分为堆内存、栈内存</p>
<p>运行时数据区域：</p>
<blockquote>
<ul>
<li>程序计数器 当前线程所执行的字节码的行号指示器，用于线程切换后能恢复到正确的执行位置，线程私有的</li>
<li>Java虚拟机栈 为虚拟机执行Java方法服务，线程私有的</li>
<li>本地方法栈 为虚拟机执行Native方法服务，线程私有的</li>
<li>Java堆 别名GC堆，内存中最大的一块，垃圾收集器管理的主要区域，细分为新生代和老年代，所有线程共享</li>
<li>方法区 别名叫非堆(永久代），用于存储已被虚拟机加载的类信息、常量、静态变量、即使编译器编译后的代码等数据，所有线程共享。运行时常量池畏方法区的一部分。回收的目标主要是针对常量池回收和对类型卸载。</li>
</ul>
</blockquote>
<p>内存相关的异常：</p>
<blockquote>
<ul>
<li>StackOverflowError异常 线程请求的栈深度大于虚拟机允许的深度，Java虚拟机栈、本地方法栈区域可能会抛出该异常</li>
<li>OutOfMemoryError异常 虚拟机栈可以动态扩张，如果扩展时无法申请足够的内存。或者在堆中没有内存来分配给对象，并且堆也无法再扩展。或者常量池无法再申请到内存。Java虚拟机栈、本地方法栈、Java堆、常量池区域可能会抛出该异常</li>
</ul>
</blockquote>
<h4 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h4><hr>
<p>最基础的算法为标记-清除，其它收集算法都是基于这种思路并对其不足进行改进而得道。</p>
<p>常用算法：</p>
<blockquote>
<ul>
<li>引用计数算法 存在循环引用问题</li>
<li>标记-清除(mark-sweep)算法 首先标记出所有需要回收的对象，在标记完后统一回收所有被标记的对象。最大的问题为标记和清除的两个过程效率都不高、回收后存在大量不连续的内存碎片、不利于大对象分配</li>
<li>复制算法 将内存空间划分为大小相等的两块，每次只使用其中一块，当一块内存用完，将存活的对象复制到另外一块内存中，然后把用完的一块内存一次清理掉。比标记-清除算法效率高，但是缺点是内存使用率不高（内存缩小为原来的一半）。这种收集算法主要用来收集新生代内存，如果对象存活率较高，就要进行较多的复制操作，效率会变低。</li>
<li>标记-整理(mark-compact)算法 标记过程与标记-清除算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象向一端移动，然后直接清理边界以外的内存。适合老年代内存回收。</li>
</ul>
</blockquote>
<p>新生代：</p>
<blockquote>
<ul>
<li>特点 每次垃圾回收时都会有大批对象死去，只有少量对象存活</li>
<li>组成 将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor。当回收时，将Eden和Survivor中还存活的对象一次性复制到另外一块Survivor空间，最后清理掉Eden和刚才用过的Survivor空间。HotSpot虚拟机默认Eden和Survivor的大小比例为8:1。当Survivor空间不够用，需要依赖其它内存（老年代）进行分配担保</li>
<li>采用复制算法</li>
</ul>
</blockquote>
<p>老年代：</p>
<blockquote>
<ul>
<li>特点 老年代中对象存活率高、没有额外空间对它进行分配担保</li>
<li>采用标记-清理、标记-整理算法</li>
</ul>
</blockquote>
<h4 id="内存分配与回收策略"><a href="#内存分配与回收策略" class="headerlink" title="内存分配与回收策略"></a>内存分配与回收策略</h4><hr>
<p>1、对象优先在Eden分配：</p>
<blockquote>
<ul>
<li>大多数情况，对象在新生代Eden区中分配。当Eden区没有足够内存空间来分配时，虚拟机将发起一次Minor GC。</li>
</ul>
</blockquote>
<p>2、大对象直接进入老年代:</p>
<blockquote>
<ul>
<li>大对象 需要大量连续内存空间的Java对象(典型的如长字符串及数组)，短命大对象，经常出现大对象容易导致内存还有不少空间时就提前触发垃圾收集以获取足够的连续空间来安置它们。</li>
</ul>
</blockquote>
<p>3、长期存活的对象将进入老年代：</p>
<blockquote>
<ul>
<li>给每个对象定义一个对象年龄计算器，对象在Survivor区中每熬过一次Minor GC，年龄就增加1岁，当它的年龄增加到一定程度（默认15岁），将会晋升到老年代。</li>
</ul>
</blockquote>
<p>4、动态对象年龄判定</p>
<blockquote>
<ul>
<li>虚拟机并不是永远地要求对象的年龄必须达到MaxTenuringThreshold才能晋升老年代</li>
<li>如果Suvivor空间中相同年龄所有对象大小总和大于Survivor空间的一半时，年龄大于或等于该年龄的对象就直接进入老年代，无须等到MaxTenuringThreshold要求的年龄</li>
</ul>
</blockquote>
<p>5、空间分配担保</p>
<blockquote>
<ul>
<li>在发生Minor GC之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果条件成立，那么Minor GC可用确保时安全的，如果不成立，则虚拟机会查看HandlePromotionFailure设置值是否允许担保失败。如果允许，那么会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次Minor GC，尽管这次Minor GC时有风险的；如果效应，或者HandlePromotionFailure设置不允许冒险，那这时也要改为进行一次Full GC。</li>
</ul>
</blockquote>
<p>两种GC：</p>
<blockquote>
<ul>
<li>Minor GC 新生代GC，Minor GC非常频繁，一般回收速度也比较快</li>
<li>Major GC／Full GC 老年代GC，出现了Major GC，经常会伴随至少一次Minor GC，Major GC的速度一般比Minor GC慢10倍以上。</li>
</ul>
</blockquote>
<h4 id="虚拟机参数"><a href="#虚拟机参数" class="headerlink" title="虚拟机参数"></a>虚拟机参数</h4><hr>
<p>-XX:+option 开启option参数</p>
<p>-XX:-option 关闭option参数</p>
<p>-XX:option=value 将option参数的值设置为value</p>
<p>整个堆大小=年轻代大小 + 年老代大小 + 持久代大小</p>
<p>配置参数：</p>
<blockquote>
<ul>
<li>-Xms 初始堆大小</li>
<li>-Xmx 最大堆大小</li>
<li>-Xmn(1.4or lator) 年轻代大小 为eden+ 2个Survivor,增大年轻代后,将会减小年老代大小.此值对系统性能影响较大,Sun官方推荐配置为整个堆的3/8</li>
<li>-XX:NewSize(1.3/1.4)  年轻代大小</li>
<li>-XX:MaxNewSize(1.3/1.4)  年轻代最大值</li>
<li>-XX:PermSize 持久代(perm gen)初始值</li>
<li>-XX:MaxPermSize 持久代最大值</li>
<li>-Xss 每个线程的堆栈大小</li>
<li>-XX:NewRatio 年轻代与年老代的比值</li>
<li>-XX:SurvivorRatio Eden区与Survivor区的大小比值</li>
</ul>
</blockquote>
<p>内存管理参数：</p>
<blockquote>
<ul>
<li>-XX:PretenureSizeThreshold 大小超过这个设置值的对象直接在老年代分配，默认值为15</li>
<li>-XX:MaxTenuringThreshold 对象晋升老年代的年龄阀值</li>
</ul>
</blockquote>
<p>调试参数：</p>
<blockquote>
<ul>
<li>-XX:+PrintFlagsFinal 输出索引参数的名称及默认值</li>
<li>-XX:+PrintGC 打印GC信息</li>
<li>-XX:+PrintGCDetails 发生垃圾收集行为时打印内存回收日志</li>
<li>-XX:+HeapDumpOnOutOfMemoryError 虚拟机在OOM异常出现之后自动生成dump文件* </li>
<li>-XX:+HeapDumpOnCtrlBreak 使用【Ctrl】+【Break】键让虚拟机生成dump文件</li>
</ul>
</blockquote>
<h4 id="JVM优化命令"><a href="#JVM优化命令" class="headerlink" title="JVM优化命令"></a>JVM优化命令</h4><hr>
<p>1、ps：虚拟机进程状况工具</p>
<p>2、jstat：虚拟机统计信息监视工具</p>
<blockquote>
<ul>
<li>显示本地或远程虚拟机进程中的类装载、内存、垃圾收集、JIT编译等运行数据</li>
<li>定位运行期虚拟机性能问题</li>
</ul>
</blockquote>
<p>3、jinfo：Java配置信息工具</p>
<p>4、jmap：Java内存映像工具</p>
<blockquote>
<ul>
<li>用于生产堆转储快照（heapdump或dump文件）</li>
</ul>
</blockquote>
<p>5、jhat：虚拟机堆转储快照分析工具</p>
<p>6、jstack：Java堆栈跟踪工具</p>
<blockquote>
<ul>
<li>用于生成虚拟机当前时刻的线程快照（threaddump或javacore文件）</li>
<li>用于定位线程出现长时间停顿的原因，如果线程间死锁、死循环、请求外部资源导致的长时间等待</li>
</ul>
</blockquote>
<h4 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h4><hr>
<p>类加载器:</p>
<p>类在虚拟机中的唯一性，由加载它的类加载器和这个类本身一同确立；比较两个类是否“相等”，只有这两个类是由同一类加载器加载的前提下才意义，否则，即使两个类来源于同一个class文件，被同一个虚拟机加载，只要加载它们的类加载器不同，那这两个类就必定不相等。</p>
<blockquote>
<ul>
<li>启动类加载器: 或称引导类加载器，Bootstrap ClassLoader，由C++语言实现，是虚拟机自身的一部分，负责将<java_home>\lib目录中或被-Xbootclasspath参数所指定的路径中的类库加载到虚拟机内存,启动类加载器无法被Java程序直接引用</java_home></li>
<li>扩展类加载器: Extension ClassLoader，由sun.misc.Launcher$ExtClassLoader实现，负责加载<java_home>\lib\ext目录中或被java.ext.dirs系统变量所指定逻辑中的所有类库。</java_home></li>
<li>应用程序类加载器: 或称系统类加载器，Applicatiion ClassLoader，由sun.misc.Launcher$AppClassLoader实现，负责加载用户类路径(ClassPath)所指定的类库，一般情况下程序默认使用应用程序类加载器。</li>
</ul>
</blockquote>
<p>由Java实现的类加载器都继承自抽象类java.lang.ClassLoader。</p>
<p>双亲委派模型：</p>
<p>工作过程是：如果一个类加载器收到类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此索引额加载请求最终都应该传送到顶层的启动类加载器中，只有当父类加载器反馈自己无法完成这个加载请求时，子加载器才会尝试自己去加载。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)</span><br><span class="line">    <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">        <span class="comment">// First, check if the class has already been loaded</span></span><br><span class="line">        Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">long</span> t0 = System.nanoTime();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    c = findBootstrapClassOrNull(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">                <span class="comment">// from the non-null parent class loader</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// If still not found, then invoke findClass in order</span></span><br><span class="line">                <span class="comment">// to find the class.</span></span><br><span class="line">                <span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line">                c = findClass(name);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// this is the defining class loader; record the stats</span></span><br><span class="line">                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">            resolveClass(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="内存模型"><a href="#内存模型" class="headerlink" title="内存模型"></a>内存模型</h4><p>java内存模型(java memory model JMM)来屏蔽各种硬件和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的内存访问效果。</p>
<p>1、主内存与工作内存</p>
<blockquote>
<ul>
<li>定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节</li>
<li>每个线程有自己的工作内存，工作内存中保存了线程使用到的变量的主内存工作副本，线程对变量的所有操作（读取、赋值）都必须在工作内存中进行；不能直接读写主内存中的变量。</li>
<li>主内存对应Java堆中的对象实例数据部分，而工作内存则对应虚拟机栈中的部分区域。</li>
</ul>
</blockquote>
<p>2、内存交互操作</p>
<blockquote>
<ul>
<li>lock(锁定)：把变量标识为一条线程独占的状态。</li>
<li>unlock(解锁)：把处于锁定状态的变量释放出来。</li>
<li>read(读取)：把变量的值从主内存传输到线程的工作内存中</li>
<li>load(载入)：把read操作从主内存中得到的变量值放入工作内存的变量副本。</li>
<li>use(使用)：把工作内存的变量值传递给执行引擎，每当虚拟机遇到一个需要使用到变量的值的字节码指令时将会执行这个操作。</li>
<li>assign(赋值) 把从执行引擎接收到的值赋给工作内存的变量，每当虚拟机遇到给变量赋值的字节码指令时执行这个操作</li>
<li>store(存储) 把工作内存的值传送到主内存中</li>
<li>write(写入）把store操作从工作内存中得到的变量的值放入主内存的变量中</li>
</ul>
</blockquote>
<p>变量从主内存复制到工作内存，要顺序执行read和load，变量从工作内存同步回主内存，要顺序执行store和write，只要求两个操作顺序执行，而没有保证是连续执行。read和load之间、store和write之间是可以插入其他指令的。如read a、read b、load b、load a。</p>
<p>3、volatile型变量</p>
<p>最轻量级的同步机制</p>
<p>特性：</p>
<blockquote>
<ul>
<li>保证变量对所有线程的可见性，可见性是指一条线程修改了这个变量的值，新值对于其他线程来说是可以立即得到的</li>
<li>每次使用之前都要刷新</li>
<li>新值立即同步到主内存</li>
<li>语义是禁止指令重排序优化</li>
</ul>
</blockquote>
<p>不符合以下规则的运算场景，仍然要通过加锁(synchronized或java.util.concurrent中的原子类)来保证原子性：</p>
<blockquote>
<ul>
<li>运算结果并不依赖当前变量的当前值，或者能够确保只有单一线程修改变量的值。</li>
<li>变量不需要与其他的状态变量共同参与不变约束。</li>
</ul>
</blockquote>
<p>4、long和double型变量的非原子协定</p>
<p>5、原子性、可见性与有序性</p>
<p>原子性：</p>
<p>可见性：除了volatile外，synchronized和final也能实现可见性。</p>
<p>有序性：如果在本线程内观察，所有操作都是有序的；如果在一个线程中观察另外一个线程，所有操作都是无序的。前半句是指线程内表现为串行的语义，后半句是指“指令重排序”现象和“工作内存与主内存同步延迟”现象。volatile和synchronized能保证线程之间操作的有序性。</p>
<p>6、先行发生原则(happen-before)</p>
<p>先行发生是Java内存模型中定义的两项操作之间的偏序关系，如果说操作A先行发生与操作B，其实是说在发生操作B之前，操作A产生的影响能被操作B观察到，“影响”包括修改了内存中共享变量的值、发送了消息、调用了方法</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://killgc.github.io/shortfeng/shortfeng/2018/03/18/mysql/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="changfeng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/shortfeng/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/shortfeng/2018/03/18/mysql/" itemprop="url">mysql</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-18T16:23:56+08:00">
                2018-03-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="并发控制"><a href="#并发控制" class="headerlink" title="并发控制"></a>并发控制</h4><p>mysql通过加锁进行并发控制。mysql有两种锁，分别是共享锁和排它锁，也叫读锁和写锁。读锁是共享的，写锁是排它的。多个读锁可以同时存在，但是写锁不能和读锁和写锁共存。在读多写少的场景比较适合读写锁。</p>
<p>按锁的粒度，分为表级锁和行级锁。</p>
<h4 id="Myisam与InnoDB区别"><a href="#Myisam与InnoDB区别" class="headerlink" title="Myisam与InnoDB区别"></a>Myisam与InnoDB区别</h4><blockquote>
<ul>
<li>InnoDB支持事务，Myisam不支持</li>
<li>InnoDB支持外键，Myisam不支持</li>
<li>InnoDB是聚集索引，数据文件和索引绑在一起，必须要主键索引；Myisam是非聚集索引，数据文件是分离的，索引保存的是数据文件的指针，主键索引和辅助索引是独立的</li>
<li>InnoDB不保存表的具体行数，执行select count(*) from table是需要全表扫描；而Myisam用一个变量保存整个表的行数，执行上述语句只需要读出该变量即可，速度很快。</li>
<li>InnoDB不支持全文索引，而Myisam支持全文索引。</li>
<li>InnoDB支持行级锁，而Myisam只支持表级锁</li>
</ul>
</blockquote>
<h4 id="聚簇索引和非聚簇索引"><a href="#聚簇索引和非聚簇索引" class="headerlink" title="聚簇索引和非聚簇索引"></a>聚簇索引和非聚簇索引</h4><p>myisam的主键索引和其它索引没有什么不同，都只是存储了数据的物理位置指针，innoDB的聚簇索引和非聚簇索引很不相同。</p>
<h5 id="聚簇索引："><a href="#聚簇索引：" class="headerlink" title="聚簇索引："></a>聚簇索引：</h5><p>InnoDB一定会建立聚簇索引，把实际数据行与相关的键值保存在一起。</p>
<blockquote>
<ul>
<li>一个表只能有一个聚簇索引</li>
<li>有主键时，根据主键创建聚簇索引</li>
<li>没有主键时，会用一个唯一且不为空的索引列作为主键创建聚簇索引</li>
<li>以上都不满足，隐式定义一个主键作为聚簇索引</li>
<li>主键不能太大</li>
</ul>
</blockquote>
<p>按主键顺序插入行<br>对应高并发，按主键顺序插入行可能会造成主键争用，主键的上限会成为热点，并发插入会导致间隙锁经侦；另外一个热点是auto_increment锁机制</p>
<h5 id="非聚簇索引："><a href="#非聚簇索引：" class="headerlink" title="非聚簇索引："></a>非聚簇索引：</h5><p>非聚簇索引（二级索引），也称为辅助索引</p>
<blockquote>
<ul>
<li>叶子节点保存的不是行的物理位置指针，而是是主键值，当行移动或数据页分裂时无需更新二级索引的物理位置指针。</li>
<li>访问数据需要两次索引查找</li>
</ul>
</blockquote>
<h4 id="B树、B-树、B-树"><a href="#B树、B-树、B-树" class="headerlink" title="B树、B+树、B*树"></a>B树、B+树、B*树</h4><p>InnoDB使用的是B+树。</p>
<h5 id="B树-B-Tree）："><a href="#B树-B-Tree）：" class="headerlink" title="B树(B-Tree）："></a>B树(B-Tree）：</h5><p>B树作为一种多路搜索树（并不是二叉的）</p>
<blockquote>
<ul>
<li>定义任意非叶子结点最多只有M个儿子；且M&gt;2；</li>
<li>根结点的儿子数为[2, M]；</li>
<li>除根结点以外的非叶子结点的儿子数为[M/2, M]；</li>
<li>每个结点存放至少M/2-1（取上整）和至多M-1个关键字；(至少2个关键字）</li>
<li>非叶子结点的关键字个数=指向儿子的指针个数-1；</li>
<li>非叶子结点的关键字：K[1], K[2], …, K[M-1]；且K[i] &lt; K[i+1]；&gt; * v非叶子结点的指针：P[1], P[2], …, P[M]；其中P[1]指向关键字小于K[1]的子树，P[M]指向关键字大于K[M-1]的子树，其它P[i]指向关键字属于(K[i-1], K[i])的子树；</li>
<li>所有叶子结点位于同一层；</li>
</ul>
</blockquote>
<p><img src="http://omu7tit09.bkt.clouddn.com/15005176551496.jpg" alt="cmd-markdown-logo"></p>
<h5 id="B-树-B-tree-："><a href="#B-树-B-tree-：" class="headerlink" title="B+树(B+tree)："></a>B+树(B+tree)：</h5><p>B+树是B树的变体，也是一种多路搜索树，其定义基本与B-树相同，除了：</p>
<blockquote>
<ul>
<li>非叶子结点的子树指针与关键字个数相同；</li>
<li>非叶子结点的子树指针P[i]，指向关键字值属于[K[i], K[i+1])的子树（B-树是开区间）；</li>
<li>为所有叶子结点增加一个链指针；</li>
<li>所有关键字都在叶子结点出现；</li>
</ul>
</blockquote>
<p>B+树性质：</p>
<blockquote>
<ul>
<li>所有关键字都出现在叶子结点的链表中（稠密索引），且链表中的关键字恰好是有序的；</li>
<li>不可能在非叶子结点命中；</li>
<li>非叶子结点相当于是叶子结点的索引（稀疏索引），叶子结点相当于是存储（关键字）数据的数据层；</li>
<li>更适合文件索引系统。</li>
</ul>
</blockquote>
<p><img src="http://omu7tit09.bkt.clouddn.com/15005182105086.jpg" alt="cmd-markdown-logo"></p>
<h5 id="B∗树："><a href="#B∗树：" class="headerlink" title="B∗树："></a>B∗树：</h5><p>B*树是B+树的变体，在B+树的非根和非叶子结点再增加指向兄弟的指针，将结点的最低利用率从1/2提高到2/3</p>
<p><img src="http://omu7tit09.bkt.clouddn.com/15005180938867.jpg" alt="cmd-markdown-logo"></p>
<p>B∗树定义了非叶子结点关键字个数至少为23M，即块的最低使用率为2/3（代替B+树的1/2）；</p>
<p>B+树的分裂：当一个结点满时，分配一个新的结点，并将原结点中1/2的数据复制到新结点，最后在父结点中增加新结点的指针；B+树的分裂只影响原结点和父结点，而不会影响兄弟结点，所以它不需要指向兄弟的指针；</p>
<p>B∗树的分裂：当一个结点满时，如果它的下一个兄弟结点未满，那么将一部分数据移到兄弟结点中，再在原结点插入关键字，最后修改父结点中兄弟结点的关键字（因为兄弟结点的关键字范围改变了）；如果兄弟也满了，则在原结点与兄弟结点之间增加新结点，并各复制1/3的数据到新结点，最后在父结点增加新结点的指针；</p>
<p>所以，B∗树分配新结点的概率比B+树要低，空间使用率更高。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://killgc.github.io/shortfeng/shortfeng/2018/03/15/spring事务传播机制和隔离级别/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="changfeng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/shortfeng/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/shortfeng/2018/03/15/spring事务传播机制和隔离级别/" itemprop="url">spring事务传播机制和隔离级别</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-15T23:24:57+08:00">
                2018-03-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="spring事务传播机制和隔离级别"><a href="#spring事务传播机制和隔离级别" class="headerlink" title="spring事务传播机制和隔离级别"></a>spring事务传播机制和隔离级别</h2><h4 id="事务传播机制"><a href="#事务传播机制" class="headerlink" title="事务传播机制"></a>事务传播机制</h4><hr>
<blockquote>
<ul>
<li>propagation_required 支持当前事务，如果不存在事务，则新建一个事务</li>
<li>propagation_supports 支持当前事务，如果不存在事务，则以非事务方式执行</li>
<li>propagation_mandatory 支持当前事务，如果不存在事务，则抛出异常</li>
<li>propagation_required_new 新建事务，如果当前存在事务，则挂起当前事务</li>
<li>propagation_not_supported 以非事务方式执行，如果当前存在事务，则把当前事务挂起</li>
<li>propagation_never 以非事务方式执行，如果当前存在事务，则抛出异常</li>
<li>propagation_nested 如果当前存在事务，则在嵌套事务内执行，如果当前没有事务，则其行为与propagation_required一样。嵌套的事务可以独立于当前事务进行单独的提交或回滚。内部事务的回滚不会对外部事务造成影响，如果外部事务commit, 嵌套事务也会被commit, 这个规则同样适用于 roll back</li>
</ul>
</blockquote>
<h4 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h4><hr>
<p>数据库事务并发的三个问题：</p>
<blockquote>
<ul>
<li>脏读 脏读发生在一个事务读取另外一个事务改写未提交的数据，如果改写在稍后被回滚，就有可能出现数据不一致。</li>
<li>不可重复读 一个事务执行相同的查询两次或两次以上，每次得到不同的数据，通常是由于另外一个事务在两次查询期间进行更新。通过锁住满足条件的记录来解决。重点在于update和delete</li>
<li>幻读 一个事务读取了几行数据，另外一个事务插入了一些数据，在后面的查询，第一个事务会发现多了一些原本不存在的记录。通过锁住满足条件及其相近的记录。重点在于insert</li>
</ul>
</blockquote>
<p>spring中对应数据库的隔离级别：</p>
<blockquote>
<ul>
<li>isolation_default 使用数据库默认的隔离级别</li>
<li>isolation_read_uncommited 读未提交，可能出现脏读、不可重复读、幻读</li>
<li>isolation_read_commited 读已提交，避免了脏读，可能会出现不可重复读、幻读</li>
<li>isolation_repeatable_read 可重复读，避免了脏读、不可重复读，可能出现幻读</li>
<li>isolation_seriablizable 串行访问，避免脏读、不可重复读、幻读。读加共享锁，写加排他锁，读写互斥</li>
</ul>
</blockquote>
<p>数据库隔离级别：</p>
<blockquote>
<ul>
<li>mysql数据库的默认隔离级别为repeatable_read，并且解决了幻读问题。</li>
<li>oracle数据库的默认隔离级别为read_commited</li>
</ul>
</blockquote>
<h4 id="回滚机制"><a href="#回滚机制" class="headerlink" title="回滚机制"></a>回滚机制</h4><p>回滚规则用于定义哪些异常会导致回滚，哪些异常不会导致回滚<br>默认情况下，只有遇到运行时异常才会回滚，遇到受检异常不回滚。</p>
<h2 id="MVCC-多版本并发控制"><a href="#MVCC-多版本并发控制" class="headerlink" title="MVCC(多版本并发控制)"></a>MVCC(多版本并发控制)</h2><p>全称为Multi-Version Currency Control，为了查询一些正在被另外事务更新的行，并且可以看到它们被更新之前的值。可以增强并发，实现查询不用等待另外事务释放锁。</p>
<p>在InnoDB中,给每行增加两个隐藏字段来实现mvcc，一个用来记录行的创建时间，一个用了记录行的过期时间（删除时间）。在实际实现中，存储的并不是时间，而是事务版本号，每开启一个新的事务，事务的版本号就会递增。<br>mysql的默认隔离级别repeatable read下，增删查改的实现为：</p>
<blockquote>
<ul>
<li>select 读取创建版本号小于或等于当前事务版本号，且删除版本号为空或大于当前事务版本号的记录，这样可以保证在读取之前记录是存在的</li>
<li>insert 创建版本号为当前事务版本号</li>
<li>update 插入一条新记录，新记录的创建版本号为当前事务版本号，原记录的删除版本号为当前事务版本号</li>
<li>delete 删除版本号为当前事务版本号</li>
</ul>
</blockquote>
<p>Mvcc只支持repeatable read和read commited隔离级别。read uncommited与Mvcc不兼容，因为不能找到适合它们事务版本的行版本，每次读取都是最新版本。serailizable与Mvcc也不兼容，因为每次读操作都会锁定它们返回的每一行数据</p>
<p>快照读和当前读：</p>
<blockquote>
<ul>
<li>快照读 读取的快照版本，也就是历史版本。普通的select是快照读</li>
<li>当前读 读取的是最新版本。update、insert、delete、select .. for update、select .. lock in share mode是当前读</li>
</ul>
</blockquote>
<p>锁定读和一致性非锁定读：</p>
<blockquote>
<ul>
<li>锁定读 事务中标准的select语句是不会加锁的，select .. for update（与update加锁一样）、select .. lock in share mode（加共享锁，其它事务只读不能修改，直到当前事务提交）两种除外。</li>
<li>一致性非锁定读  简称一致性读，读的是数据库某个时间点的快照。如果隔离级别是repeatable_read，同一个事务中的所有一致性非锁定读都读的是事务中第一个读读到的快照版，如果隔离级别为read_commited，那么事务的每一个一致性非锁定读都会读到自己刷新的快照版本。一致性非锁定读不会给它访问的表加任何形式的锁，因此其它事务可以并发的修改它们。</li>
</ul>
</blockquote>
<p>悲观锁和乐观锁：</p>
<blockquote>
<ul>
<li>悲观锁 数据库总是认为别人会修改它所操作的数据，因此在操作数据过程中将数据加锁</li>
<li>乐观锁 总是认为别人不会修改，通过版本来实现</li>
</ul>
</blockquote>
<p>锁：</p>
<blockquote>
<ul>
<li>record lock（记录锁） 在索引记录上加锁</li>
<li>grap locks（间隙锁） 在索引记录之间加锁，或者在第一个索引记录之前加锁，或者在最后一个索引记录之后加锁</li>
<li>next key lock 在索引记录上加锁，并且在索引记录之间的间隙加锁，相当于record lock与grap locks的结合</li>
</ul>
</blockquote>
<p>一致性读保证了可重复读，间隙锁防止了幻读。</p>
<h4 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h4><p>同一service两个方法之间调用，被调用方法的@Transaction配置会被忽略</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">migration方法调用singleProcess方法singleProcess方法的</span><br><span class="line">事务配置会被忽略</span><br><span class="line">出现的结果是两个方法执行的数据库操作都成功了</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">migration</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        B2bPartnerTmpDO record = <span class="keyword">new</span> B2bPartnerTmpDO();</span><br><span class="line">        record.setId(<span class="number">100008001L</span>);</span><br><span class="line">        record.setCorpDescription(<span class="string">"22"</span>);</span><br><span class="line">        partnerTmpManager.updateByPrimaryKeySelective(record);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            singleProcess();<span class="comment">//调用目标对象的方法，不能触发对singleProcess方法的事务增强</span></span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception ex)&#123;</span><br><span class="line">            log.error(<span class="string">"出现异常:"</span>+ex.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span>(propagation=Propagation.REQUIRES_NEW)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">singleProcess</span><span class="params">()</span></span>&#123;</span><br><span class="line">        B2bPartnerTmpDO record = <span class="keyword">new</span> B2bPartnerTmpDO();</span><br><span class="line">        record.setId(<span class="number">100008002L</span>);</span><br><span class="line">        record.setCorpDescription(<span class="string">"33"</span>);</span><br><span class="line">        partnerTmpManager.updateByPrimaryKeySelective(record);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"singleProcess出现异常"</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">migration方法调用singleProcess方法，singleProcess方法的</span><br><span class="line">事务配置会被忽略</span><br><span class="line">出现的结果是两个方法的代码合并在一起了，执行的数据库操作都回滚了</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">migration</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        B2bPartnerTmpDO record = <span class="keyword">new</span> B2bPartnerTmpDO();</span><br><span class="line">        record.setId(<span class="number">100008001L</span>);</span><br><span class="line">        record.setCorpDescription(<span class="string">"22"</span>);</span><br><span class="line">        partnerTmpManager.updateByPrimaryKeySelective(record);</span><br><span class="line"></span><br><span class="line">        singleProcess();<span class="comment">//调用目标对象的方法，不能触发对singleProcess方法的事务增强</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"migration出现异常"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span>(propagation=Propagation.REQUIRES_NEW)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">singleProcess</span><span class="params">()</span></span>&#123;</span><br><span class="line">        B2bPartnerTmpDO record = <span class="keyword">new</span> B2bPartnerTmpDO();</span><br><span class="line">        record.setId(<span class="number">100008002L</span>);</span><br><span class="line">        record.setCorpDescription(<span class="string">"33"</span>);</span><br><span class="line">        partnerTmpManager.updateByPrimaryKeySelective(record);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">结果是migration的sql执行成功，singleProcess方法是新启一个事务，</span><br><span class="line">事务出现异常进行回滚，singleProcess方法sql执行回滚了。</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MigrationService migrationService;<span class="comment">//引用代理自身的代理对象</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">migration</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        B2bPartnerTmpDO record = <span class="keyword">new</span> B2bPartnerTmpDO();</span><br><span class="line">        record.setId(<span class="number">100008001L</span>);</span><br><span class="line">        record.setCorpDescription(<span class="string">"22"</span>);</span><br><span class="line">        partnerTmpManager.updateByPrimaryKeySelective(record);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//调用代理对象的方法，能触发对singleProcess方法的事务增强</span></span><br><span class="line">            migrationService.singleProcess();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception ex)&#123;</span><br><span class="line">            log.error(<span class="string">"出现异常:"</span>+ex.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span>(propagation=Propagation.REQUIRES_NEW)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">singleProcess</span><span class="params">()</span></span>&#123;</span><br><span class="line">        B2bPartnerTmpDO record = <span class="keyword">new</span> B2bPartnerTmpDO();</span><br><span class="line">        record.setId(<span class="number">100008002L</span>);</span><br><span class="line">        record.setCorpDescription(<span class="string">"33"</span>);</span><br><span class="line">        partnerTmpManager.updateByPrimaryKeySelective(record);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"singleProcess出现异常"</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">虽然在migration方法中对singleProcess方法出现的异常进行<span class="keyword">catch</span>了，</span><br><span class="line"><span class="keyword">catch</span>后面的sql语句也能执行下去，但是最终的结果是所有数据库操作都回滚了。</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MigrationService migrationService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">migration</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        B2bPartnerTmpDO record = <span class="keyword">new</span> B2bPartnerTmpDO();</span><br><span class="line">        record.setId(<span class="number">100008001L</span>);</span><br><span class="line">        record.setCorpDescription(<span class="string">"22"</span>);</span><br><span class="line">        partnerTmpManager.updateByPrimaryKeySelective(record);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//migrationService.singleProcess();</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            migrationService.singleProcess();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception ex)&#123;</span><br><span class="line">            log.error(<span class="string">"出现异常:"</span>+ex.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        B2bPartnerTmpDO record2 = <span class="keyword">new</span> B2bPartnerTmpDO();</span><br><span class="line">        record2.setId(<span class="number">100008003L</span>);</span><br><span class="line">        record2.setCorpDescription(<span class="string">"44"</span>);</span><br><span class="line">        partnerTmpManager.updateByPrimaryKeySelective(record2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">singleProcess</span><span class="params">()</span></span>&#123;</span><br><span class="line">        B2bPartnerTmpDO record = <span class="keyword">new</span> B2bPartnerTmpDO();</span><br><span class="line">        record.setId(<span class="number">100008002L</span>);</span><br><span class="line">        record.setCorpDescription(<span class="string">"33"</span>);</span><br><span class="line">        partnerTmpManager.updateByPrimaryKeySelective(record);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"singleProcess出现异常"</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://killgc.github.io/shortfeng/shortfeng/2018/03/13/性能优化相关linux命令/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="changfeng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/shortfeng/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/shortfeng/2018/03/13/性能优化相关linux命令/" itemprop="url">性能优化相关linux命令</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-13T16:48:10+08:00">
                2018-03-13
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="性能优化相关linux命令"><a href="#性能优化相关linux命令" class="headerlink" title="性能优化相关linux命令"></a>性能优化相关linux命令</h2><hr>
<h4 id="top命令"><a href="#top命令" class="headerlink" title="top命令"></a>top命令</h4><p>top命令是Linux下常用的性能分析工具，能够实时显示系统中各个进程的资源占用状况，类似于Windows的任务管理器，查看系统平均负载和 CPU 使用率</p>
<p>平均负载有三个数字：63.66，58.39，57.18，分别表示过去 1 分钟、5 分钟、15 分钟机器的负载。按照经验，若数值小于 0.7*CPU 个数，则系统工作正常；若超过这个值，甚至达到 CPU 核数的四五倍，则系统的负载就明显偏高</p>
<p>命令格式：<br>top [参数]</p>
<p>命令功能：<br>显示当前系统正在执行的进程的相关信息，包括进程ID、内存占用率、CPU占用率等</p>
<p>默认以pid倒序排序<br>命令参数：</p>
<pre><code>top    [-a | -d | -e | -c &lt;mode&gt;]
       [-F | -f]
       [-h]
       [-i &lt;interval&gt;]
       [-l &lt;samples&gt;]
       [-ncols &lt;columns&gt;]
       [-o &lt;key&gt;] [-O &lt;skey&gt;]
       [-R | -r]
       [-S]
       [-s &lt;delay&gt;]
       [-n &lt;nprocs&gt;]
       [-stats &lt;keys&gt;]
       [-pid &lt;processid&gt;]
       [-user &lt;username&gt;]
       [-U &lt;username&gt;]
       [-u]

 [-a | -d | -e | -c &lt;mode&gt;] 
 -c &lt;mode&gt;
    a 累积模式,从top命令执行开始计算
    d delta模式
    e 绝对模式，计算事件的绝对数量
    n 无事件模式，为默认模式
 -a 等同与-c a，类似的-d、-e 分别等同与-c d、-c e

 [-F | -f]
 -F 不计算共享内存
 -f 计算共享内存，默认

 [-h] 打印信息并退出 **这个参数执行不了**
 [-i &lt;interval&gt;] 每隔多少秒更新信息
 [-l &lt;samples&gt;]
 [-ncols &lt;columns&gt;]
 [-o &lt;key&gt;] [-O &lt;secondaryKey&gt;]
 -o &lt;key&gt; 第一排序字段
 -O &lt;secondaryKey&gt; 第二排序字段
 支持以下key，key前面可以带上+或-，用于说明倒序还是正序：
 pid 默认
 cpu cpu_me CPU time charged to me by other processes.
 cpu_others  CPU time charged to other processes by me
 csw 上下文切换次数
 time 执行时间
 threads 别名为th，线程数量（总的线程数/运行中线程数）
 ports 别名prt，机器端口数量
 mregion 别名mreg, reg，内存区数量
 mem 内存大小
 rprvt 常驻私有地址空间大小
 purg 可移除内存大小
 vsize  Total memory size.
 vprvt  Private address space size.
 kprvt  Private kernel memory size.
 kshrd  Shared kernel memory size.
 pgrp   Process group id.
 ppid   Parent process id.
 state  alias: pstate Process state.
 uid    User ID.
 wq     alias: #wq, workqueue
              The workqueue total/running.

 faults alias: fault
              The number of page faults.

 cow    alias: cow_faults
              The copy-on-write faults.

 user   alias: username Username.

 msgsent Total number of mach messages sent.

 msgrecv Total number of mach messages received.

 sysbsd Total BSD syscalls.

 sysmach Total Mach syscalls.


 -R     Do not traverse and  report  the  memory  object  map  for  each
       process.

-r     Traverse  and report the memory object map for each process (de-
       fault).

-S     Display the global statistics for swap and purgeable memory.

-s &lt;delay&gt; 每隔多少秒更新显示
       Set the delay between updates to &lt;delay&gt; seconds.   The  default delay between updates is 1 second.

-stats &lt;keys&gt;
       Only  display  the  comma separated statistics.  See the -o flag
       for the valid &lt;keys&gt;.

-pid &lt;processid&gt;
       Only display &lt;processid&gt; in top.  This option may  be  specified
       multiple times.

-user &lt;user&gt;
       Only display processes owned by &lt;user&gt;.

-U &lt;user&gt;
       This is an alias for -user.

-u     This is an alias equivalent to: -o cpu -O time.
</code></pre><p>交互式命令：</p>
<pre><code>?      Display the help screen.  Any character exits help screen  mode.
       This command always works, even in the middle of a command.

^L     Redraw the screen.

c&lt;mode&gt;
       Set output mode to &lt;mode&gt;.  The supported modes are:

       a      Accumulative mode.

       d      Delta mode.

       e      Event mode.

       n      Non-event mode.

O&lt;skey&gt;
       Use &lt;skey&gt; as a secondary key when ordering the process display.
       See the -o option for key names.

o&lt;key&gt;
       Order the process display by sorting on &lt;key&gt; in descending  or-
       der.   A  +  or - can be prefixed to the key name to specify as-
       cending or descending order, respectively.  The  supported  keys
       and alises are listed with the -o option above.

q      Quit.

r      Toggle traversal and reporting of the memory object map for each
       process.

S&lt;signal&gt;&lt;pid&gt;
       Send &lt;sig&gt; to &lt;pid&gt;.  &lt;sig&gt; can be specified either as a  number
       or  as a name (for example, HUP).  The default signal starts out
       as TERM.  Each time a signal is successfully sent,  the  default
       signal is updated to be that signal.  &lt;pid&gt; is a process id.

s&lt;delay&gt;
       Set the delay between updates to &lt;delay&gt; seconds.
U&lt;user&gt;
       Only  display processes owned by &lt;user&gt;.  Either the username or
       uid number can be specified.  To display  all  processes,  press
       enter without entering a username or uid number.
</code></pre><p>示例：</p>
<pre><code>top -o cpu -O +rsize -s 5 -n 20
       Sort the processes according to CPU usage (descending) and resi-
       dent memory size (ascending), sample and update the display at 5
       second intervals, and limit the display to 20 processes.

top -c d
       Run top in delta mode.

top -stats pid,command,cpu,th,pstate,time
       Display  only the specified statistics, regardless of any growth
       of the terminal.  If the terminal is too small, only the statis-
       tics that fit will be displayed.
</code></pre><p>相关命令：</p>
<p>kill(2), vm_stat(1), signal(3), vmmap(1)</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/shortfeng/page/2/">2</a><a class="extend next" rel="next" href="/shortfeng/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/shortfeng/images/avatar.gif"
               alt="changfeng" />
          <p class="site-author-name" itemprop="name">changfeng</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/shortfeng/archives/">
                <span class="site-state-item-count">16</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">changfeng</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/shortfeng/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/shortfeng/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/shortfeng/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/shortfeng/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/shortfeng/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/shortfeng/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/shortfeng/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/shortfeng/js/src/motion.js?v=5.1.2"></script>



  
  

  
    <script type="text/javascript" src="/shortfeng/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/shortfeng/js/src/post-details.js?v=5.1.2"></script>

  

  


  <script type="text/javascript" src="/shortfeng/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  






  





  

  

  

  

  

  

</body>
</html>
